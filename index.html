<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Geoportal Solicitudes Ciudadanas</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <!-- PWA Configuration -->
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#922B21">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Geoportal">
  <link rel="apple-touch-icon" href="img/logo/logo.png">

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

  <!-- Leaflet MarkerCluster -->
  <script src="https://unpkg.com/leaflet.markercluster/dist/leaflet.markercluster.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.Default.css" />

  <!-- Bootstrap -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <!-- SheetJS -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>

  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>

<style>
  /* Base */
  body { margin:0; font-family:'Montserrat', sans-serif; }
  .navbar { background-color:#922B21; color:#fff; }
  .navbar-brand span { color:#fff; font-weight:600; }

  /* Layout principal */
  .main-container {
    display:flex;
    height:calc(100vh - 60px);
    margin-top:60px;
    position: relative;
    overflow: hidden; /* Ocultar cualquier contenido que salga del contenedor */
  }

  /* Sidebar */
  #sidebar {
    width:700px;
    background:#f5f5f5;
    padding:10px;
    overflow-y:auto;
    position: relative;
    transition: all 0.35s ease; /* Animar cambios */
    flex-shrink: 0; /* No reducir el sidebar */
  }

  /* Mapa */
  #map { 
    flex:1; 
    width: 100%;
    min-width: 0; /* Permitir que el mapa se comprima si es necesario */
  }
  canvas { margin-bottom:20px; }

  /* Pestaña de toggle (posicionada dinámicamente por JS) */
  #sidebarToggleTab {
    background: #922B21;
    color: #fff;
    padding: 8px 10px;
    font-size: 16px;
    cursor: pointer;
    z-index: 1001;
    border-radius: 0 4px 4px 0;
    user-select: none;
    border: none;
  }

  .sidebar-title {
    font-size: 12px;
    margin-top: 10px;
    margin-bottom: 8px;
  }

  .tabla-resumen table {
    font-size: 12px;
  }

  .chart-container {
    height: 250px;
    position: relative;
    margin-bottom: 15px;
  }

  /* Contenedor específico para gráfica de colonias (más alto para mostrar todos los nombres) */
  #chartColonias {
    max-height: 450px !important;
  }

  /* Loading overlay */
  #loadingOverlay {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.45);
    z-index: 3000;
    display: flex;
    align-items: center;
    justify-content: center;
    color: #fff;
  }
  #loadingOverlay .box {
    background: rgba(0,0,0,0.7);
    padding: 12px 18px;
    border-radius: 6px;
    font-size: 16px;
    font-weight: 600;
  }

  /* Estilos para datalist en móviles */
  datalist, datalist option {
    background: white;
    color: black;
    padding: 8px;
  }
  datalist option {
    padding: 8px;
    background: white;
    color: black;
  }

  /* Autocompletado (fallback móvil) */
  .input-group { position: relative; }
  .autocomplete-list {
    position: absolute;
    top: 100%;
    left: 0;
    right: 0;
    max-height: 240px;
    overflow-y: auto;
    background: #fff;
    border: 1px solid #ccc;
    border-top: none;
    z-index: 3000;
    box-shadow: 0 4px 10px rgba(0,0,0,0.08);
  }
  .autocomplete-item {
    padding: 8px 10px;
    cursor: pointer;
    font-size: 14px;
    line-height: 1.2;
  }
  .autocomplete-item:hover { background: #f3f3f3; }
</style>
</head>
<body>

  <!-- Encabezado -->
  <nav class="navbar navbar-expand-lg fixed-top">
    <div class="container-fluid">
      <a class="navbar-brand" href="#">
        <img src="img/logo/logo.png" alt="logo" style="height:40px;">
        <span>Solicitudes Ciudadanas - Alcaldía Álvaro Obregón</span>
      </a>
    </div>
  </nav>

  <!-- Aviso para móviles: girar el celular -->
  <div id="rotateMessage" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.7);z-index:2000;display:flex;align-items:center;justify-content:center;color:#fff;">
    <div style="text-align:center;padding:20px;max-width:320px;margin:auto;">
      <div style="font-size:28px;margin-bottom:10px;">↪️</div>
      <div style="font-size:18px;font-weight:600;">Gire su dispositivo</div>
      <div style="margin-top:8px;font-size:14px;">Para una mejor visualización, use el modo horizontal.</div>
    </div>
  </div>

  <!-- Overlay de carga -->
  <div id="loadingOverlay"><div class="box">Cargando datos</div></div>

  <!-- Contenedor principal -->
  <div class="main-container">

    <!-- Pestaña flotante de toggle (fuera del sidebar para evitar conflictos de posicionamiento) -->
    <div id="sidebarToggleTab">☰</div>

    <!-- Sidebar -->
    <div id="sidebar">
      <h4 class="sidebar-title">Buscar por folio o colonia</h4>
      <div class="input-group mb-3">
        <input type="text" id="buscadorGeneral" class="form-control" placeholder="Ingrese folio o colonia" list="sugerenciasColonias">
        <datalist id="sugerenciasColonias"></datalist>
        <button class="btn btn-primary btn-sm" id="btnBuscarGeneral">Buscar</button>
        <button class="btn btn-secondary btn-sm" id="btnResetBuscar">Limpiar</button>
      </div>

      <h4 class="sidebar-title">Filtrar por tipo</h4>
      <select id="filtroTipo" class="form-select mb-3">
        <option value="Todos">Todos</option>
      </select>

      <h4 class="sidebar-title">Filtrar por estado</h4>
      <select id="filtroEstado" class="form-select mb-3">
        <option value="Todos">Todos</option>
      </select>

      <h4 class="sidebar-title">Filtrar por mes</h4>
      <select id="filtroMes" class="form-select mb-3">
        <option value="Todos">Todos</option>
      </select>

      <button class="btn btn-success btn-sm mb-3" id="btnAplicarFiltros">Aplicar filtros</button>

      <h4 class="sidebar-title">Estadísticas</h4>
      <div class="chart-container">
        <canvas id="chartTipos"></canvas>
      </div>
      <div class="chart-container">
        <canvas id="chartColonias"></canvas>
      </div>
      <div class="chart-container">
        <canvas id="chartEstados"></canvas>
      </div>

      <h4 class="sidebar-title">Tabla resumen</h4>
      <div id="tablaResumen" class="tabla-resumen"></div>
    </div>

    <!-- Mapa -->
    <div id="map"></div>
  </div>

<script>
  // ========== VARIABLES GLOBALES ==========
  // Detectar si es móvil (RECALCULAR dinámicamente)
  let isMobile = window.innerWidth <= 768;
  
  // Declaraciones e inicialización de variables globales usadas en el script
  var map;
  var coloniasLayer = null;
  var solicitudesGeoJSON = null;
  var solicitudes = [];
  var solicitudPorId = {};
  var allIds = [];
  var indiceTipo = {};
  var indiceEstado = {};
  var indiceMes = {};
  var estadisticasPorColonia = {};
  var puntosLayer = null;
  var legendControl = null;
  var puntosToggleControl = null;
  var chartTipos = null, chartColonias = null, chartEstados = null;
  var showPuntos = true;
  var zoomendHandlerAdded = false;
  var coloniaSeleccionada = null;
  var selectedOutline = null;
  var normToColoniaName = {};
  var lastTipoForTable = null;
  
  // Lista de colonias para autocompletado (fallback móvil)
  var coloniasList = [];
  var autocompleteContainer = null;
  
  // ✅ NUEVA OPTIMIZACIÓN: Índice espacial para matching rápido de coordenadas
  var coordIndexMap = new Map(); // Clave: "lon,lat" -> array de IDs

  // Inicializar el mapa antes de cargar capas y datos
  try {
    map = L.map('map').setView([19.35, -99.2], 13);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);
  } catch (e) {
    console.error('Error inicializando mapa:', e);
  }

  function generarTablaResumen(datos){
    // Mantener la función original por compatibilidad si hace falta
    let resumen = {};
    datos.forEach(s => {
      if(!s["Fecha reporte"] || !s["Estado Reporte"]) return;
      let fecha = new Date(s["Fecha reporte"]);
      if(isNaN(fecha)) return;

      let mesClave = fecha.getFullYear()+"-"+(fecha.getMonth()+1).toString().padStart(2,"0");
      if(!resumen[mesClave]) {
        resumen[mesClave] = { Atendido:0, Pendiente:0, "En atención":0, "No compete":0 };
      }

      let estado = s["Estado Reporte"].trim();
      if(estado==="Pendiente") resumen[mesClave].Pendiente++;
      else if(estado==="En atención") resumen[mesClave]["En atención"]++;
      else if(estado==="Atendido") resumen[mesClave].Atendido++;
      else if(estado==="No compete") resumen[mesClave]["No compete"]++;
    });

    let mesesOrdenados = Object.keys(resumen).sort();
    let tabla = `<table class="table table-striped"><thead><tr>
      <th>Mes</th><th>Atendido</th><th>Pendiente</th><th>En atención</th><th>No compete</th>
    </tr></thead><tbody>`;
    let totales = { Atendido: 0, Pendiente: 0, "En atención": 0, "No compete": 0 };
    mesesOrdenados.forEach(m => {
      const r = resumen[m];
      const [anio, mesNum] = m.split("-");
      let nombreMes = new Date(anio, parseInt(mesNum) - 1).toLocaleString('es-ES', { month: 'long' });
      nombreMes = nombreMes.charAt(0).toUpperCase() + nombreMes.slice(1);
      tabla += `<tr>
        <td>${nombreMes} ${anio}</td>
        <td>${r.Atendido}</td>
        <td>${r.Pendiente}</td>
        <td>${r["En atención"]}</td>
        <td>${r["No compete"]}</td>
      </tr>`;
      Object.keys(totales).forEach(k => { totales[k] += r[k]; });
    });
    tabla += `<tr style="font-weight:bold;">
      <td>Total</td>
      <td>${totales.Atendido}</td>
      <td>${totales.Pendiente}</td>
      <td>${totales["En atención"]}</td>
      <td>${totales["No compete"]}</td>
    </tr></tbody></table>`;
    document.getElementById("tablaResumen").innerHTML = tabla;
  }

  // Generar tabla estática: Top 10 colonias y Últimas 10 solicitudes según filtro Tipo
  function generarTablaEstatica(tipo) {
    // Filtrar por tipo (o todos)
    const filtradasPorTipo = solicitudes.filter(s => {
      if (!s) return false;
      if (tipo === 'Todos' || !tipo) return true;
      return s["Tipo de reporte"] === tipo;
    });

    // Top 10 colonias
    const conteoCol = {};
    filtradasPorTipo.forEach(s => {
      const col = s["Colonia"] || 'Sin colonia';
      conteoCol[col] = (conteoCol[col] || 0) + 1;
    });
    const topColonias = Object.entries(conteoCol)
      .map(([col, cnt]) => ({col, cnt}))
      .sort((a,b) => b.cnt - a.cnt)
      .slice(0,10);

    // Últimas 10 solicitudes (por fecha)
    const ultimasSolicitudes = filtradasPorTipo
      .filter(s => s["Fecha reporte"])
      .map(s => ({
        folio: s["Número folio"],
        fecha: new Date(s["Fecha reporte"]),
        colonia: s["Colonia"] || 'Sin colonia',
        ciudadano: s["Nombre Ciudadano"] || 'N/A',
        telefono: s["Teléfono"] || 'N/A',
        tipo: s["Tipo de reporte"] || 'N/A',
        estado: s["Estado Reporte"] || 'N/A',
        referencia: s["Punto de referencia"] || 'N/A'
      }))
      .filter(x => !isNaN(x.fecha))
      .sort((a,b) => b.fecha - a.fecha)
      .slice(0,10);

    // Construir HTML
    let html = '<div style="display:flex;flex-direction:column;gap:12px">';

    // Top Colonias
    html += '<div><b>Top 10 Colonias (por número de solicitudes)</b>';
    html += '<table class="table table-sm"><thead><tr><th>Colonia</th><th>Total</th></tr></thead><tbody>';
    topColonias.forEach(c => {
      html += `<tr><td>${c.col}</td><td>${c.cnt}</td></tr>`;
    });
    if (topColonias.length === 0) html += '<tr><td colspan="2">No hay datos</td></tr>';
    html += '</tbody></table></div>';

    // Últimas solicitudes
    html += '<div><b>Últimas 10 Solicitudes</b>';
    html += '<table class="table table-sm"><thead><tr><th>Folio</th><th>Fecha</th><th>Colonia</th><th>Ciudadano</th><th>Teléfono</th><th>Tipo</th><th>Estado</th></tr></thead><tbody>';
    ultimasSolicitudes.forEach(s => {
      html += `<tr><td>${s.folio}</td><td>${s.fecha.toLocaleString()}</td><td>${s.colonia}</td><td>${s.ciudadano}</td><td>${s.telefono}</td><td>${s.tipo}</td><td>${s.estado}</td></tr>`;
    });
    if (ultimasSolicitudes.length === 0) html += '<tr><td colspan="7">No hay solicitudes</td></tr>';
    html += '</tbody></table></div>';

    html += '</div>';
    document.getElementById('tablaResumen').innerHTML = html;
  }

  function classColor(i){
    const colors = ['#DBD8D7','#FAEAE3','#FD9D8C','#F72F35','#99250F','#4A0E03'];
    return colors[Math.min(Math.max(i,0), colors.length-1)];
  }

  function getJenksBreaks(data, numClasses) {
    data = data.filter(v => !isNaN(v)).sort((a, b) => a - b);
    if (data.length === 0) return [];

    let matrices = [], variance = [];
    for (let i = 0; i < data.length + 1; i++) {
      let tmp1 = [], tmp2 = [];
      for (let j = 0; j < numClasses + 1; j++) { tmp1.push(0); tmp2.push(0); }
      matrices.push(tmp1); variance.push(tmp2);
    }

    for (let i = 1; i < numClasses + 1; i++) {
      matrices[0][i] = 1; variance[0][i] = 0;
      for (let j = 1; j < data.length + 1; j++) { variance[j][i] = Infinity; }
    }

    for (let l = 2; l < data.length + 1; l++) {
      let sum = 0, sumSquares = 0, w = 0;
      for (let m = 1; m < l + 1; m++) {
        let i3 = l - m + 1, val = data[i3 - 1];
        w++; sum += val; sumSquares += val * val;
        let varianceVal = sumSquares - (sum * sum) / w;
        let i4 = i3 - 1;
        if (i4 !== 0) {
          for (let j = 2; j < numClasses + 1; j++) {
            if (variance[l][j] >= (varianceVal + variance[i4][j - 1])) {
              variance[l][j] = varianceVal + variance[i4][j - 1];
              matrices[l][j] = i3;
            }
          }
        }
      }
      variance[l][1] = sumSquares - (sum * sum) / w;
      matrices[l][1] = 1;
    }

    let k = data.length, kclass = [];
    for (let j = numClasses; j > 0; j--) {
      let id = matrices[k][j] - 1;
      kclass.push(data[id]);
      k = matrices[k][j] - 1;
    }
    kclass.push(data[data.length - 1]);
    return kclass.reverse();
  }

  // Normalizar cadenas: trim, mayúsculas, eliminar tildes/diacríticos, quitar signos
  function normalizeKey(s) {
    if (s === undefined || s === null) return null;
    try {
      return String(s)
        .trim()
        .toUpperCase()
        .normalize('NFD')
        .replace(/[\u0000-\u001F\u007F]/g, '')
        .replace(/[\u0300-\u036f]/g, '')
        .replace(/[^A-Z0-9\s]/g, '')
        .replace(/\s+/g, ' ');
    } catch (e) {
      return String(s).trim().toUpperCase();
    }
  }

  // ✅ NUEVA OPTIMIZACIÓN: Simplificar geometrías de polígonos para reducir vértices
  function simplifyGeometry(coords, tolerance = 0.001) {
    if (!coords || coords.length < 3) return coords;
    // Douglas-Peucker simplificado para reducir puntos en polígonos
    const simplified = [];
    const len = coords.length;
    // Siempre mantener primer y último punto
    simplified.push(coords[0]);
    // Tomar cada N puntos (más agresivo en móviles)
    const step = isMobile ? 3 : 2;
    for (let i = step; i < len - 1; i += step) {
      simplified.push(coords[i]);
    }
    simplified.push(coords[len - 1]);
    return simplified;
  }

  // ✅ NUEVA OPTIMIZACIÓN: Debounce para evitar múltiples renders rápidos
  function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
      const later = () => {
        clearTimeout(timeout);
        func(...args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  }

  // ========== OBTENER IDs FILTRADOS ==========
  // Obtener IDs filtrados; si ignoreColonia=true, se omite el filtro por coloniaSeleccionada
  function obtenerIdsFiltrados(filtroTipo, filtroEstado, filtroMes, ignoreColonia = false) {
    let setIds = new Set(allIds);

    if (filtroTipo !== "Todos") {
      setIds = new Set(indiceTipo[filtroTipo] || []);
    }
    if (filtroEstado !== "Todos") {
      const idsEstado = new Set(indiceEstado[filtroEstado] || []);
      setIds = new Set([...setIds].filter(id => idsEstado.has(id)));
    }
    if (filtroMes !== "Todos") {
      const idsMes = new Set(indiceMes[filtroMes] || []);
      setIds = new Set([...setIds].filter(id => idsMes.has(id)));
    }
    if (!ignoreColonia && coloniaSeleccionada) {
      const nombreColonia = coloniaSeleccionada.feature?.properties?.NOMBRE;
      const nombreNorm = normalizeKey(nombreColonia);
      setIds = new Set([...setIds].filter(id => solicitudPorId[id]["ColoniaNorm"] === nombreNorm));
    }
    return [...setIds];
  }

  // ========== LOADING OVERLAY HELPERS ==========
  function showLoading() {
    try {
      const d = document.getElementById('loadingOverlay');
      if (d) d.style.display = 'flex';
    } catch (e) { console.log('showLoading error', e); }
  }
  function hideLoading() {
    try {
      const d = document.getElementById('loadingOverlay');
      if (d) d.style.display = 'none';
    } catch (e) { console.log('hideLoading error', e); }
  }

  // ========== PRECÁLCULO DE ÍNDICES Y ESTADÍSTICAS ==========
  function precalcularIndices() {
    solicitudPorId = {};
    allIds = [];
    indiceTipo = {};
    indiceEstado = {};
    indiceMes = {};
    estadisticasPorColonia = {};
  coordIndexMap.clear(); // Limpiar índice espacial

    solicitudes.forEach((s, idx) => {
      s._id = idx;
      solicitudPorId[idx] = s;
      allIds.push(idx);

      // ✅ NUEVA OPTIMIZACIÓN: Construir índice espacial
      const lon = Number(s["Coordenada X"]);
      const lat = Number(s["Coordenada Y"]);
      if (!isNaN(lon) && !isNaN(lat)) {
        // Redondear a 6 decimales para agrupación (~10cm precisión)
        const key = `${lon.toFixed(6)},${lat.toFixed(6)}`;
        if (!coordIndexMap.has(key)) coordIndexMap.set(key, []);
        coordIndexMap.get(key).push(idx);
      }

      const tipo = s["Tipo de reporte"] || "Sin tipo";
        console.log('✅ Índice espacial construido con', coordIndexMap.size, 'ubicaciones únicas');
      if (!indiceTipo[tipo]) indiceTipo[tipo] = [];
      indiceTipo[tipo].push(idx);

      const estado = s["Estado Reporte"] || "Sin estado";
      if (!indiceEstado[estado]) indiceEstado[estado] = [];
      indiceEstado[estado].push(idx);

      if (s["Fecha reporte"]) {
        const fecha = new Date(s["Fecha reporte"]);
        if (!isNaN(fecha)) {
          const mesNombre = fecha.toLocaleString('es-ES', { month: 'long' });
          if (!indiceMes[mesNombre]) indiceMes[mesNombre] = [];
          indiceMes[mesNombre].push(idx);
        }
      }

      const col = s["Colonia"];
      const colNorm = s["ColoniaNorm"] || normalizeKey(col);
      if (colNorm) {
        if (!estadisticasPorColonia[colNorm]) {
          estadisticasPorColonia[colNorm] = { tipos: {}, estados: {}, meses: {}, originalNames: {} };
        }
        estadisticasPorColonia[colNorm].tipos[tipo] = (estadisticasPorColonia[colNorm].tipos[tipo] || 0) + 1;
        estadisticasPorColonia[colNorm].estados[estado] = (estadisticasPorColonia[colNorm].estados[estado] || 0) + 1;
        if (s["Fecha reporte"] && !isNaN(new Date(s["Fecha reporte"]))) {
          const mesNombre = new Date(s["Fecha reporte"]).toLocaleString('es-ES', { month: 'long' });
          estadisticasPorColonia[colNorm].meses[mesNombre] = (estadisticasPorColonia[colNorm].meses[mesNombre] || 0) + 1;
        }
        // Guardar ejemplos de nombres originales para referencia
        if (col) {
          estadisticasPorColonia[colNorm].originalNames[col] = (estadisticasPorColonia[colNorm].originalNames[col] || 0) + 1;
        }
      }
    });
  }

  // ========== RENDERIZAR FUNCIÓN OPTIMIZADA ==========
  function renderizar(filtroTipo, filtroEstado, filtroMes) {
    // Mostrar overlay de carga al iniciar render
    try { showLoading(); } catch(e){}

    // Prevenir renderizado si no hay datos cargados
    if (!solicitudes || solicitudes.length === 0 || !solicitudesGeoJSON) {
      try { hideLoading(); } catch(e){}
      return;
    }
    
    // ✅ OPTIMIZACIÓN 1: Usar índices precalculados en lugar de .forEach()
    // idsFiltradosRespectCol: respetan la selección de colonia (para puntos)
    const idsFiltradosRespectCol = obtenerIdsFiltrados(filtroTipo, filtroEstado, filtroMes, false);
    // idsFiltradosIgnoreCol: ignoran la selección de colonia (para choropleth, charts y tabla)
    const idsFiltradosIgnoreCol = obtenerIdsFiltrados(filtroTipo, filtroEstado, filtroMes, true);

    // ===== Agregados por colonia basados en los ids filtrados IGNORANDO la selección puntual de colonia =====
    const countsByColNorm = {}; // { norm: { total: n, estados: {estado: n} } }
    idsFiltradosIgnoreCol.forEach(id => {
      const s = solicitudPorId[id];
      if (!s) return;
      const norm = s["ColoniaNorm"] || normalizeKey(s["Colonia"]);
      const estado = s["Estado Reporte"] || 'Sin estado';
      if (!norm) return;
      if (!countsByColNorm[norm]) countsByColNorm[norm] = { total: 0, estados: {} };
      countsByColNorm[norm].total += 1;
      countsByColNorm[norm].estados[estado] = (countsByColNorm[norm].estados[estado] || 0) + 1;
    });
    
    // Contadores para gráficas
    var tipos = {}, estados = {}, fechas = {};

    // Para las métricas de las gráficas usaremos idsFiltradosIgnoreCol (no limitar por la colonia seleccionada)
    idsFiltradosIgnoreCol.forEach(id => {
      const s = solicitudPorId[id];
      if (!s) return;
      const tipo = s["Tipo de reporte"];
      const estado = s["Estado Reporte"];
      const fecha = s["Fecha reporte"] ? new Date(s["Fecha reporte"]) : null;

      if (tipo) tipos[tipo] = (tipos[tipo] || 0) + 1;
      if (estado) {
        if (estado === "Pendiente" || estado === "En atención") {
          estados["Pendiente/En Atención"] = (estados["Pendiente/En Atención"] || 0) + 1;
        } else {
          estados[estado] = (estados[estado] || 0) + 1;
        }
      }
      if (fecha && !isNaN(fecha)) {
        const clave = fecha.getFullYear() + "-" + (fecha.getMonth() + 1).toString().padStart(2, "0");
        fechas[clave] = (fechas[clave] || 0) + 1;
      }
    });

    // ✅ OPTIMIZACIÓN 2: Filtrar GeoJSON una sola vez para los PUNTOS según idsFiltradosRespectCol
    const allowedIds = new Set(idsFiltradosRespectCol);
    const featuresFiltradas = solicitudesGeoJSON.features.filter((f, idx) => {
      if (!f.geometry || f.geometry.type !== "Point" || !Array.isArray(f.geometry.coordinates)) return false;
      
      // ✅ MEJORA: Usar índice espacial para búsqueda rápida
      const lon = f.geometry.coordinates[0];
      const lat = f.geometry.coordinates[1];
      const key = `${lon.toFixed(6)},${lat.toFixed(6)}`;
      const idsEnCoordenada = coordIndexMap.get(key);
      
      if (!idsEnCoordenada) return false;
      
      // Verificar si alguno de los IDs en esta coordenada está en allowedIds
      return idsEnCoordenada.some(id => allowedIds.has(id));
    });

    // ✅ OPTIMIZACIÓN 3: Inicializar capa de puntos UNA SOLA VEZ
    if (!puntosLayer) {
      // En móviles: reducir complejidad de MarkerCluster
      const clusterConfig = isMobile 
        ? { maxClusterRadius: 80, disableClusteringAtZoom: 16 }
        : { maxClusterRadius: 50 };
      puntosLayer = L.markerClusterGroup(clusterConfig);
      
      // Agregar solo si no está en mapa
      if (!map.hasLayer(puntosLayer)) {
        map.addLayer(puntosLayer);
      }

      // ✅ OPTIMIZACIÓN 4: Event listener ÚNICO para zoom
      if (!zoomendHandlerAdded) {
        map.on('zoomend', function() {
          if (!puntosLayer) return;
          // Respetar el estado de showPuntos: sólo mostrar cuando el usuario lo permita
          if (map.getZoom() >= 14 && showPuntos) {
            if (!map.hasLayer(puntosLayer)) map.addLayer(puntosLayer);
          } else {
            if (map.hasLayer(puntosLayer)) map.removeLayer(puntosLayer);
          }
        });
        zoomendHandlerAdded = true;
      }
    }

      // Asegurar control de leyenda y toggle están creados
      if (!legendControl || !puntosToggleControl) createMapControls();

    // ✅ LIMPIAR layers de la capa anterior (sin recrear)
    puntosLayer.clearLayers();

    // ✅ Agregar features filtradas
    const capaGeoJson = L.geoJson(
      { type: "FeatureCollection", features: featuresFiltradas },
      {
        pointToLayer: function (feature, latlng) {
          return L.circleMarker(latlng, {
            radius: 4,
            fillColor: "#F7EC1B",
            color: "#26261C",
            weight: 1,
            opacity: 1,
            fillOpacity: 0.7
          }).bindPopup(`
            <b>Folio:</b> ${feature.properties["Número folio"]}<br>
            <b>Ciudadano:</b> ${feature.properties["Nombre Ciudadano"] || 'N/A'}<br>
            <b>Teléfono:</b> ${feature.properties["Teléfono"] || 'N/A'}<br>
            <b>Tipo:</b> ${feature.properties["Tipo de reporte"]}<br>
            <b>Estado:</b> ${feature.properties["Estado Reporte"]}<br>
            <b>Punto de referencia:</b> ${feature.properties["Punto de referencia"] || 'N/A'}
          `);
        }
      }
    );

    puntosLayer.addLayer(capaGeoJson);
    // Si el usuario tiene puntos desactivados, asegurarnos de no mostrarlos
    if (showPuntos) {
      if (!map.hasLayer(puntosLayer)) map.addLayer(puntosLayer);
      // indicar visualmente en el botón
      const btn = document.getElementById('btnTogglePuntos'); if (btn) btn.style.opacity = '1';
    } else {
      if (map.hasLayer(puntosLayer)) map.removeLayer(puntosLayer);
      const btn = document.getElementById('btnTogglePuntos'); if (btn) btn.style.opacity = '0.4';
    }

    // Fitear solo si hay colonia seleccionada
    if (coloniaSeleccionada && coloniaSeleccionada.getBounds) {
      try {
        map.fitBounds(coloniaSeleccionada.getBounds());
      } catch (e) {
        console.log("Error fitBounds:", e);
      }
    }

    // ========== GRÁFICAS ==========
    const chartLimit = isMobile ? 6 : 10; // En móviles mostrar solo 6 para mejor rendimiento
    function prepararDatos(obj) {
      let arr = Object.entries(obj);
      arr.sort((a, b) => b[1] - a[1]);
      arr = arr.slice(0, chartLimit);
      return {
        labels: arr.map(e => e[0]),
        values: arr.map(e => e[1])
      };
    }

    let datosTipos = prepararDatos(tipos);
    let datosEstados = prepararDatos(estados);

    // Gráfica Tipos
    if (chartTipos) {
      chartTipos.data.labels = datosTipos.labels;
      chartTipos.data.datasets[0].data = datosTipos.values;
      chartTipos.update(isMobile ? 'none' : 'none');
    } else {
      chartTipos = new Chart(document.getElementById('chartTipos'), {
        type: 'bar',
        data: {
          labels: datosTipos.labels,
          datasets: [{
            label: 'Solicitudes por tipo',
            data: datosTipos.values,
            backgroundColor: '#922B21'
          }]
        },
        options: {
          indexAxis: 'y',
          responsive: true,
          maintainAspectRatio: false,
          animation: { duration: isMobile ? 0 : 0 },
          plugins: { legend: { display: false } }
        }
      });
    }

    // Gráfica Colonias (usar countsByColNorm calculados desde idsFiltrados)
    const conteoColoniasEstados = {};
    Object.entries(countsByColNorm).forEach(([colNorm, info]) => {
      const displayName = normToColoniaName[colNorm] || (estadisticasPorColonia[colNorm] && Object.keys(estadisticasPorColonia[colNorm].originalNames || {})[0]) || colNorm;
      conteoColoniasEstados[displayName] = info.estados || {};
      conteoColoniasEstados[displayName]._total = info.total || 0;
    });

    let coloniasOrdenadas = Object.entries(conteoColoniasEstados)
      .map(([colonia, estados]) => {
        const total = estados._total || Object.values(estados).reduce((a, b) => a + b, 0);
        // remove _total from estados copy
        const estadosCopy = Object.assign({}, estados);
        delete estadosCopy._total;
        return { colonia, estados: estadosCopy, total };
      })
      .sort((a, b) => b.total - a.total)
      .slice(0, chartLimit);

    const labelsColonias = coloniasOrdenadas.map(c => c.colonia);
    const totalsColonias = coloniasOrdenadas.map(c => c.total);

    const ordenEstados = ["Pendiente", "En atención", "Atendido", "No compete"];
    const coloresEstados = {
      "Pendiente": "#991B02",
      "En atención": "#ED8718",
      "Atendido": "#0BC700",
      "No compete": "#545454"
    };

    const datasetsColonias = ordenEstados.map(est => ({
      label: est,
      data: coloniasOrdenadas.map(c => c.estados[est] || 0),
      backgroundColor: coloresEstados[est] || "#999"
    }));

    if (chartColonias) {
      chartColonias.data.labels = labelsColonias;
      chartColonias.data.datasets = datasetsColonias;
      chartColonias.data.totals = totalsColonias;
      chartColonias.update(isMobile ? 'none' : 'none');
    } else {
      chartColonias = new Chart(document.getElementById('chartColonias'), {
        type: 'bar',
        data: {
          labels: labelsColonias,
          datasets: datasetsColonias,
          totals: totalsColonias
        },
        options: {
          indexAxis: 'y',
          responsive: true,
          maintainAspectRatio: false,
          animation: { duration: 0 },
          plugins: {
            tooltip: {
              callbacks: {
                label: function(context) {
                  const total = context.chart.data.totals[context.dataIndex];
                  const valor = context.raw;
                  return `${context.dataset.label}: ${valor} de ${total}`;
                }
              }
            },
            legend: { position: 'bottom', labels: { font: { size: 10 } } }
          },
          scales: {
            x: { stacked: true, ticks: { precision: 0 } },
            y: { stacked: true, ticks: { font: { size: 9 } }, maxRotation: 0, minRotation: 0 }
          }
        }
      });
    }

    // Gráfica Estados
    if (chartEstados) {
      chartEstados.data.labels = datosEstados.labels;
      chartEstados.data.datasets[0].data = datosEstados.values;
      chartEstados.update(isMobile ? 'none' : 'none');
    } else {
      chartEstados = new Chart(document.getElementById('chartEstados'), {
        type: 'bar',
        data: {
          labels: datosEstados.labels,
          datasets: [{
            label: 'Solicitudes por estado',
            data: datosEstados.values,
            backgroundColor: '#36a2eb'
          }]
        },
        options: {
          indexAxis: 'y',
          responsive: true,
          maintainAspectRatio: false,
          animation: { duration: isMobile ? 0 : 0 },
          plugins: { legend: { display: false } }
        }
      });
    }

    // ========== TABLA RESUMEN ==========
    // Restaurar comportamiento anterior: la tabla resumen se genera
    // a partir de los datos filtrados (ignorando la selección puntual de colonia)
    // y usa la función `generarTablaResumen` como antes.
    // En móviles: deferimos la actualización para después del renderizado de gráficas
    try {
      const datosParaTabla = idsFiltradosIgnoreCol.map(id => solicitudPorId[id]).filter(Boolean);
      if (isMobile) {
        // Aplazar tabla en móviles para que gráficas se rendericen primero
        setTimeout(() => generarTablaResumen(datosParaTabla), 100);
      } else {
        generarTablaResumen(datosParaTabla);
      }
    } catch (e) {
      console.log('Error actualizando tablaResumen:', e);
    }

    // ========== CHOROPLETH ==========
    if (coloniasLayer) {
      // Primero calcular total de solicitudes por colonia respetando filtros
      const totalsArr = [];
      const totalsByCol = {};

      // Obtener totals a partir de countsByColNorm (ya filtrados)
      coloniasLayer.eachLayer(layer => {
        const nombre = layer.feature.properties.NOMBRE;
        const nombreNorm = layer.feature.properties._normName || normalizeKey(nombre);
        const info = countsByColNorm[nombreNorm];
        const total = info ? info.total : 0;
        totalsByCol[nombre] = total;
        if (total > 0) totalsArr.push(total);
      });

      const numClasses = 5;
      if (totalsArr.length === 0) {
        // No hay datos: pintar todo gris claro
        coloniasLayer.eachLayer(layer => {
          try {
            layer.setStyle({ fillColor: "#eee", fillOpacity: 0.2, color: "#555", weight: 1 });
            const nombre = layer.feature.properties.NOMBRE;
            const total = totalsByCol[nombre] || 0;
            layer.bindPopup(`<b>${nombre}</b><br>Solicitudes: ${total}`);
          } catch (e) {
            console.log("Error en choropleth (sin datos):", e);
          }
        });
      } else {
        // Calcular quiebres Jenks (manejar si hay menos valores que clases)
        const clases = Math.min(numClasses, totalsArr.length);
        let breaks = [];
        try {
          breaks = getJenksBreaks(totalsArr, clases);
        } catch (e) {
          console.log('Error calculando Jenks:', e);
          // fallback: usar percentiles simples
          totalsArr.sort((a,b)=>a-b);
          breaks = [];
          for (let i=1;i<=clases;i++) {
            const idx = Math.floor((totalsArr.length * i) / clases) - 1;
            breaks.push(totalsArr[Math.max(0, Math.min(totalsArr.length-1, idx))]);
          }
        }

        // Asegurar que los quiebres estén ordenados y sean únicos
        breaks = Array.from(new Set(breaks)).sort((a,b)=>a-b);

        coloniasLayer.eachLayer(layer => {
          const nombre = layer.feature.properties.NOMBRE;
          const total = totalsByCol[nombre] || 0;

          let fill = "#eee";
          let opacity = 0.2;

          if (total > 0) {
            // Determinar clase: 0..(breaks.length-1)
            let cls = 0;
            for (let i = 0; i < breaks.length; i++) {
              if (total <= breaks[i]) { cls = i; break; }
              cls = i;
            }
            fill = classColor(cls);
            // mapear opacidad según clase (más solicitudes -> mayor opacidad)
            opacity = 0.35 + (cls / Math.max(1, breaks.length - 1)) * 0.55;
          }

          try {
            layer.setStyle({ fillColor: fill, fillOpacity: opacity, color: "#555", weight: 1 });
            layer.bindPopup(`<b>${nombre}</b><br>Solicitudes: ${total}`);
          } catch (e) {
            console.log("Error en choropleth (pintado):", e);
          }
        });
        // Actualizar leyenda con los quiebres calculados
        try { updateLegend(breaks); } catch (e) { console.log('Error actualizando leyenda:', e); }
      }
    }
    else {
      // Si no hay coloniasLayer o sin datos, limpiar la leyenda
      try { updateLegend(null); } catch(e){}
    }

    // Ocultar overlay al terminar render (delay mayor en móviles)
    try { setTimeout(hideLoading, isMobile ? 800 : 500); } catch(e){}
  }

  // ========== GENERAR TABLA RESUMEN ==========
  // Tabla resumen (con Pendientes/En Atención + Indicador dinámico + Totales en negritas)
  function generarTablaResumen(datos){
    let resumen = {};
    datos.forEach(s => {
      if(!s["Fecha reporte"] || !s["Estado Reporte"]) return;
      let fecha = new Date(s["Fecha reporte"]);
      if(isNaN(fecha)) return;

      // clave por año-mes
      let mesClave = fecha.getFullYear()+"-"+(fecha.getMonth()+1).toString().padStart(2,"0");
      if(!resumen[mesClave]) {
        resumen[mesClave] = {
          Atendido:0,
          Pendiente:0,
          "En atención":0,
          "No compete":0,
          PendientesMes:0,
          PendientesAcumulado:0,
          IndicadorDias:0
        };
      }

      let estado = s["Estado Reporte"].trim();
      if(estado==="Pendiente"){
        resumen[mesClave].Pendiente++;
      } else if(estado==="En atención"){
        resumen[mesClave]["En atención"]++;
      } else if(estado==="Atendido"){
        resumen[mesClave].Atendido++;
      } else if(estado==="No compete"){
        resumen[mesClave]["No compete"]++;
      }
    });

    // Orden cronológico de meses (YYYY-MM)
    let mesesOrdenados = Object.keys(resumen).sort();

    // Calcular Pendientes/En Atención, acumulado y el indicador dinámico
    let acumulado = 0;
    let totalMeses = mesesOrdenados.length;
    mesesOrdenados.forEach((m, idx) => {
      const fila = resumen[m];
      fila.PendientesMes = fila.Pendiente + fila["En atención"];
      acumulado += fila.PendientesMes;
      fila.PendientesAcumulado = acumulado;

      // Factor dinámico: último mes = 1, hacia atrás +30 cada vez
      let distanciaDesdeFinal = (totalMeses - 1) - idx;
      let factor = distanciaDesdeFinal * 30;
      if (distanciaDesdeFinal === 0) factor = 1; // último mes = 1
      fila.IndicadorDias = fila.PendientesMes * factor;
    });

    // Renderizar tabla
    let tabla = `<table class="table table-striped">
      <thead><tr>
        <th>Mes</th><th>Atendido</th><th>Pendiente</th><th>En atención</th>
        <th>No compete</th><th>Pendientes/En Atención</th>
        <th>Pendientes/En Atención (Acumulado)</th>
        <th>Indicador de días por solicitudes</th>
      </tr></thead><tbody>`;

    // Variables para totales
    let totalAtendido = 0, totalPendiente = 0, totalEnAtencion = 0, totalNoCompete = 0;
    let totalPendMes = 0, totalPendAcum = 0, totalIndicador = 0;

    mesesOrdenados.forEach(m => {
      const r = resumen[m];
      const [anio, mesNum] = m.split("-");
      let nombreMes = new Date(anio, parseInt(mesNum)-1).toLocaleString('es-ES',{month:'long'});
      nombreMes = nombreMes.charAt(0).toUpperCase() + nombreMes.slice(1);

      tabla += `<tr>
        <td>${nombreMes} ${anio}</td>
        <td>${r.Atendido.toLocaleString('es-MX')}</td>
        <td>${r.Pendiente.toLocaleString('es-MX')}</td>
        <td>${r["En atención"].toLocaleString('es-MX')}</td>
        <td>${r["No compete"].toLocaleString('es-MX')}</td>
        <td>${r.PendientesMes.toLocaleString('es-MX')}</td>
        <td>${r.PendientesAcumulado.toLocaleString('es-MX')}</td>
        <td>${r.IndicadorDias.toLocaleString('es-MX')}</td>
      </tr>`;

      // Acumular totales
      totalAtendido += r.Atendido;
      totalPendiente += r.Pendiente;
      totalEnAtencion += r["En atención"];
      totalNoCompete += r["No compete"];
      totalPendMes += r.PendientesMes;
      totalPendAcum = r.PendientesAcumulado; // el acumulado final es el último valor
      totalIndicador += r.IndicadorDias;
    });

    // Fila de totales en negritas
    tabla += `<tr style="font-weight:bold;">
      <td>Total</td>
      <td>${totalAtendido.toLocaleString('es-MX')}</td>
      <td>${totalPendiente.toLocaleString('es-MX')}</td>
      <td>${totalEnAtencion.toLocaleString('es-MX')}</td>
      <td>${totalNoCompete.toLocaleString('es-MX')}</td>
      <td>${totalPendMes.toLocaleString('es-MX')}</td>
      <td>${totalPendAcum.toLocaleString('es-MX')}</td>
      <td>${totalIndicador.toLocaleString('es-MX')}</td>
    </tr>`;

    tabla += `</tbody></table>`;
    document.getElementById("tablaResumen").innerHTML = tabla;
  }

  // ========== INICIALIZADOR FILTROS ==========
  function inicializarFiltros() {
    let tiposUnicos = [...new Set(solicitudes.map(s => s["Tipo de reporte"]).filter(Boolean))];
    let selectTipo = document.getElementById("filtroTipo");
    tiposUnicos.forEach(t => {
      let opt = document.createElement("option");
      opt.value = t;
      opt.textContent = t;
      selectTipo.appendChild(opt);
    });

    let estadosUnicos = [...new Set(solicitudes.map(s => s["Estado Reporte"]).filter(Boolean))];
    let selectEstado = document.getElementById("filtroEstado");
    estadosUnicos.forEach(e => {
      let opt = document.createElement("option");
      opt.value = e;
      opt.textContent = e;
      selectEstado.appendChild(opt);
    });

    let mesesUnicos = [...new Set(solicitudes.map(s => {
      if (!s["Fecha reporte"]) return null;
      let fecha = new Date(s["Fecha reporte"]);
      if (isNaN(fecha)) return null;
      return fecha.toLocaleString('es-ES', { month: 'long' });
    }).filter(Boolean))];

    let selectMes = document.getElementById("filtroMes");
    mesesUnicos.forEach(m => {
      let opt = document.createElement("option");
      opt.value = m;
      opt.textContent = m.charAt(0).toUpperCase() + m.slice(1);
      selectMes.appendChild(opt);
    });
  }

  // ========== CARGAR DATOS ==========
  console.log("Iniciando carga de datos...");
  // Mostrar overlay de carga al iniciar
  try { if (typeof showLoading === 'function') showLoading(); } catch(e){}
  
  let coloniasLoaded = false;
  let solicitudesLoaded = false;

  function iniciarSiTodoEstaListo() {
    if (coloniasLoaded && solicitudesLoaded) {
      console.log("✅ TODOS LOS DATOS CARGADOS");
      precalcularIndices();
      inicializarFiltros();
      renderizar("Todos", "Todos", "Todos");
      console.log("✅ Inicialización completa");
      try { if (typeof hideLoading === 'function') hideLoading(); } catch(e){}
    }
  }

  // Cargar colonias
  fetch("archivos/vectores/colonias_wgs84_geojson_renombrado.geojson")
    .then(res => res.json())
    .then(data => {
      if (coloniasLayer) return; // Evitar duplicación
      // Desactivado: mantemos geometría original para evitar deformaciones en móvil
      
      coloniasLayer = L.geoJson(data, {
        renderer: L.canvas(),
        smoothFactor: 0,
        style: function(feature) {
          return {
            color: "#555",
            weight: 1,
            fill: true,
            fillColor: "#eee",
            fillOpacity: 0.6
          };
        },
        onEachFeature: function(feature, layer) {
          const nombreColonia = feature.properties.NOMBRE;
          // Guardar versión normalizada en la propiedad para comparaciones rápidas
          try { feature.properties._normName = normalizeKey(nombreColonia); } catch(e) { feature.properties._normName = null; }
          layer.bindPopup(`<b>${nombreColonia}</b><br>Solicitudes: 0`);

          layer.on('click', function(e) {
            if (L && L.DomEvent) L.DomEvent.stopPropagation(e);

            if (selectedOutline) {
              map.removeLayer(selectedOutline);
              selectedOutline = null;
            }

            selectedOutline = L.geoJSON(layer.toGeoJSON(), {
              style: { color: "red", weight: 3, fill: false }
            }).addTo(map);

            if (selectedOutline.bringToFront) selectedOutline.bringToFront();

            layer.openPopup();
            coloniaSeleccionada = layer;
            // Renderizar respetando los filtros activos (no forzar 'Todos')
            try {
              const tipo = document.getElementById('filtroTipo')?.value || 'Todos';
              const estado = document.getElementById('filtroEstado')?.value || 'Todos';
              const mes = document.getElementById('filtroMes')?.value || 'Todos';
              renderizar(tipo, estado, mes);
            } catch (e) {
              renderizar('Todos','Todos','Todos');
            }
          });

          layer.on('popupclose', function() {
            if (selectedOutline) {
              map.removeLayer(selectedOutline);
              selectedOutline = null;
            }
            if (coloniaSeleccionada === layer) {
              coloniaSeleccionada = null;
              // Restaurar la visualización previa llamando a renderizar con filtros actuales
              try {
                const tipo = document.getElementById('filtroTipo')?.value || 'Todos';
                const estado = document.getElementById('filtroEstado')?.value || 'Todos';
                const mes = document.getElementById('filtroMes')?.value || 'Todos';
                renderizar(tipo, estado, mes);
              } catch (e) {
                renderizar('Todos','Todos','Todos');
              }
            }
          });
        }
      }).addTo(map);

      coloniasLayer.eachLayer(layer => {
        let nombre = layer.feature.properties.NOMBRE;
        let norm = layer.feature.properties._normName || normalizeKey(nombre);
        if (norm) normToColoniaName[norm] = nombre;
        if(nombre) {
          // Guardar para autocompletado
          coloniasList.push(nombre);
          let opt = document.createElement("option");
          opt.value = nombre;
          document.getElementById("sugerenciasColonias").appendChild(opt);
        }
      });

      // Dejar única y ordenada la lista de colonias
      try {
        coloniasList = Array.from(new Set(coloniasList)).sort((a,b)=>a.localeCompare(b,'es',{sensitivity:'base'}));
      } catch(e) {}

      coloniasLoaded = true;
      console.log("✅ Colonias cargadas");
      // Inicializar el autocompletado una vez que tengamos colonias
      try { initializeAutocompleteFallback(); } catch(e) { console.log('Autocomplete init error', e); }
      iniciarSiTodoEstaListo();
    })
    .catch(err => console.error("Error al cargar colonias:", err));

  // Cargar solicitudes
  fetch("archivos/solicitudes/Diciembre2025.geojson")
    .then(res => res.json())
    .then(data => {
      if (solicitudesGeoJSON) return; // Evitar duplicación
      
      solicitudesGeoJSON = data;

      // En móviles: procesar en chunks para no bloquear UI
      const processChunk = (features, startIdx = 0) => {
        const chunkSize = isMobile ? 1000 : 5000; // Procesar en lotes
        const endIdx = Math.min(startIdx + chunkSize, features.length);
        
        for (let i = startIdx; i < endIdx; i++) {
          const f = features[i];
          if (!f.geometry || f.geometry.type !== "Point" || !Array.isArray(f.geometry.coordinates)) continue;
          
          const rawCol = f.properties["name"] || f.properties["NOMBRE"] || f.properties["colonia"] || null;
          solicitudes.push({
            "Número folio": f.properties["Número folio"],
            "Tipo de reporte": f.properties["Tipo de reporte"],
            "Estado Reporte": f.properties["Estado Reporte"],
            "Fecha reporte": f.properties["Fecha reporte"],
            "Nombre Ciudadano": f.properties["Nombre Ciudadano"],
            "Teléfono": f.properties["Teléfono"],
            "Punto de referencia": f.properties["Punto de referencia"],
            "Coordenada X": f.geometry.coordinates[0],
            "Coordenada Y": f.geometry.coordinates[1],
            "Colonia": rawCol,
            "ColoniaNorm": normalizeKey(rawCol)
          });
        }
        
        // Si hay más datos, procesar siguiente chunk de forma asíncrona
        if (endIdx < features.length) {
          setTimeout(() => processChunk(features, endIdx), 10);
        } else {
          console.log("✅ Solicitudes cargadas:", solicitudes.length);
          solicitudesLoaded = true;
          iniciarSiTodoEstaListo();
        }
      };

      // Iniciar procesamiento
      processChunk(data.features);
    })
    .catch(err => console.error("Error al cargar solicitudes:", err));

  // ========== EVENT LISTENERS ==========
  let btnAplicarFiltros = document.getElementById("btnAplicarFiltros");
  let btnBuscarGeneral = document.getElementById("btnBuscarGeneral");
  let btnResetBuscar = document.getElementById("btnResetBuscar");
  
    // ✅ NUEVA OPTIMIZACIÓN: Debounce para renderizado suave
    const renderizarDebounced = debounce(renderizar, 150);
  
  // Agregar listeners solo una vez
  if (btnAplicarFiltros && !btnAplicarFiltros.hasListener) {
    btnAplicarFiltros.addEventListener("click", () => {
      const tipo = document.getElementById("filtroTipo").value;
      const estado = document.getElementById("filtroEstado").value;
      const mes = document.getElementById("filtroMes").value;
      // Usar debounce para evitar clics múltiples rápidos
      renderizarDebounced(tipo, estado, mes);
    });
    btnAplicarFiltros.hasListener = true;
  }

  if (btnBuscarGeneral && !btnBuscarGeneral.hasListener) {
    btnBuscarGeneral.addEventListener("click", () => {
      let valor = document.getElementById("buscadorGeneral").value.trim();
      if (!valor) return;

      let solicitud = solicitudes.find(s => s["Número folio"] == valor);
      if (solicitud) {
        let lat = parseFloat(solicitud["Coordenada Y"]);
        let lon = parseFloat(solicitud["Coordenada X"]);
        if (!isNaN(lat) && !isNaN(lon)) {
          map.setView([lat, lon], 17);
          
          // Crear y mostrar popup con la información del folio
          const popupContent = `
            <div style="max-width: 250px;">
              <b>Folio:</b> ${solicitud["Número folio"]}<br>
              <b>Ciudadano:</b> ${solicitud["Nombre Ciudadano"] || 'N/A'}<br>
              <b>Teléfono:</b> ${solicitud["Teléfono"] || 'N/A'}<br>
              <b>Tipo:</b> ${solicitud["Tipo de reporte"]}<br>
              <b>Estado:</b> ${solicitud["Estado Reporte"]}<br>
              <b>Punto de referencia:</b> ${solicitud["Punto de referencia"] || 'N/A'}<br>
              <b>Fecha:</b> ${solicitud["Fecha reporte"] || 'N/A'}
            </div>
          `;
          L.popup()
            .setLatLng([lat, lon])
            .setContent(popupContent)
            .openOn(map);
        }

        let tipo = solicitud["Tipo de reporte"];
        let estado = solicitud["Estado Reporte"];
        document.getElementById("filtroTipo").value = tipo || "Todos";
        document.getElementById("filtroEstado").value = estado || "Todos";
        renderizar(tipo || "Todos", estado || "Todos", "Todos");
        return;
      }
      // Si no es folio, intentar buscar por colonia (normalizando texto)
      const valorNorm = normalizeKey(valor);
      let foundColoniaLayer = null;
      try {
        if (coloniasLayer) {
          coloniasLayer.eachLayer(layer => {
            const name = layer.feature && (layer.feature.properties && (layer.feature.properties.NOMBRE || layer.feature.properties.name));
            const n = normalizeKey(name);
            if (n && valorNorm && n === valorNorm) {
              foundColoniaLayer = layer;
            }
          });
        }
      } catch (e) {
        console.log('Error buscando colonia:', e);
      }

      if (foundColoniaLayer) {
        // Hacer zoom a la colonia
        try {
          map.fitBounds(foundColoniaLayer.getBounds());
        } catch (e) {
          console.log("Error en fitBounds:", e);
        }
        
        // Seleccionar colonia y dibujar contorno rojo
        coloniaSeleccionada = foundColoniaLayer;
        
        if (selectedOutline) {
          map.removeLayer(selectedOutline);
          selectedOutline = null;
        }
        
        selectedOutline = L.geoJSON(foundColoniaLayer.toGeoJSON(), {
          style: { color: "red", weight: 3, fill: false }
        }).addTo(map);
        
        if (selectedOutline.bringToFront) selectedOutline.bringToFront();

        // Renderizar con filtros actuales
        const tipo = document.getElementById('filtroTipo')?.value || 'Todos';
        const estado = document.getElementById('filtroEstado')?.value || 'Todos';
        const mes = document.getElementById('filtroMes')?.value || 'Todos';
        renderizar(tipo, estado, mes);
        return;
      }

      alert("No se encontró folio ni colonia con: " + valor);
    });
    btnBuscarGeneral.hasListener = true;
  }

  // ========== AUTOCOMPLETADO FALLBACK (MÓVIL Y ESCRITORIO) ==========
  function initializeAutocompleteFallback() {
    // Activar en todos los dispositivos para experiencia uniforme
    try {
      const input = document.getElementById('buscadorGeneral');
      if (!input) return;
      const group = input.closest('.input-group') || document.getElementById('sidebar');
      if (!group) return;

      // Crear contenedor si no existe
      if (!autocompleteContainer) {
        autocompleteContainer = document.createElement('div');
        autocompleteContainer.id = 'autocompleteList';
        autocompleteContainer.className = 'autocomplete-list';
        autocompleteContainer.style.display = 'none';
        group.appendChild(autocompleteContainer);
      }

      const renderSuggestions = (q) => {
        if (!q || q.trim().length < 1) { autocompleteContainer.style.display = 'none'; autocompleteContainer.innerHTML=''; return; }
        const qn = normalizeKey(q);
        const matches = [];
        for (let i = 0; i < coloniasList.length; i++) {
          const name = coloniasList[i];
          const nn = normalizeKey(name);
          if (nn && nn.indexOf(qn) !== -1) {
            matches.push({ name, pos: nn.indexOf(qn) });
          }
          if (matches.length >= 50) break; // límite razonable
        }
        matches.sort((a,b)=> a.pos - b.pos || a.name.localeCompare(b.name,'es',{sensitivity:'base'}));
        const top = matches.slice(0, 15);
        if (top.length === 0) { autocompleteContainer.style.display = 'none'; autocompleteContainer.innerHTML=''; return; }

        let html = '';
        top.forEach(m => {
          html += `<div class="autocomplete-item" data-value="${m.name.replace(/"/g,'&quot;')}">${m.name}</div>`;
        });
        autocompleteContainer.innerHTML = html;
        autocompleteContainer.style.display = 'block';

        // Click handler por item
        Array.from(autocompleteContainer.children).forEach(el => {
          el.addEventListener('click', () => {
            const val = el.getAttribute('data-value');
            input.value = val || '';
            autocompleteContainer.style.display = 'none';
            // No disparamos búsqueda automática; usuario decide
          }, { once: true });
        });
      };

      // Listeners del input
      input.addEventListener('input', () => renderSuggestions(input.value));
      input.addEventListener('focus', () => {
        if (input.value && input.value.length > 0) renderSuggestions(input.value);
      });
      input.addEventListener('blur', () => {
        // pequeño delay para permitir click en la lista
        setTimeout(() => { if (autocompleteContainer) autocompleteContainer.style.display = 'none'; }, 150);
      });

      // Enter: si hay sugerencias visibles, tomar la primera
      input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && autocompleteContainer && autocompleteContainer.style.display !== 'none') {
          const first = autocompleteContainer.querySelector('.autocomplete-item');
          if (first) {
            e.preventDefault();
            input.value = first.getAttribute('data-value');
            autocompleteContainer.style.display = 'none';
          }
        }
      });
    } catch (e) {
      console.log('Autocomplete fallback error:', e);
    }
  }

  if (btnResetBuscar && !btnResetBuscar.hasListener) {
    btnResetBuscar.addEventListener("click", () => {
      // Mostrar loading overlay y deshabilitar botón de inmediato (síncrono)
      const loadingDiv = document.getElementById('loadingOverlay');
      if (loadingDiv) loadingDiv.style.display = 'flex';
      btnResetBuscar.disabled = true;
      btnResetBuscar.style.opacity = '0.5';
      
      document.getElementById("buscadorGeneral").value = "";
      document.getElementById("filtroTipo").value = "Todos";
      document.getElementById("filtroEstado").value = "Todos";
      document.getElementById("filtroMes").value = "Todos";
      coloniaSeleccionada = null;
      if (selectedOutline) {
        map.removeLayer(selectedOutline);
        selectedOutline = null;
      }
      renderizar("Todos", "Todos", "Todos");
      map.setView([19.35, -99.2], 13);
      // Re-habilitar botón después de que termine la carga
      setTimeout(() => {
        btnResetBuscar.disabled = false;
        btnResetBuscar.style.opacity = '1';
      }, 600);
    });
    btnResetBuscar.hasListener = true;
  }

  // Toggle Sidebar
  let sidebarToggleTab = document.getElementById("sidebarToggleTab");
  if (sidebarToggleTab && !sidebarToggleTab.hasListener) {
    let sidebarIsHidden = false; // Estado interno del toggle
    const sidebarWidth = 700; // ancho del sidebar en px (debe coincidir con CSS)
    const tabHeight = 40;
    
    // Función para actualizar el estado visual del sidebar y la pestaña
    function updateSidebarState() {
      const sidebar = document.getElementById('sidebar');
      const tab = document.getElementById('sidebarToggleTab');
      if (!sidebar || !tab) return;
      
      if (sidebarIsHidden) {
        // Ocultar: establecer width a 36px (solo la pestaña visible) y transform
        sidebar.style.width = '36px';
        sidebar.style.padding = '0';
        sidebar.style.overflow = 'visible';
        tab.style.position = 'fixed';
        tab.style.left = '0px';
        tab.style.top = '70px';
        tab.style.width = '36px';
        tab.textContent = '☰';
        console.log('Sidebar ocultado');
      } else {
        // Mostrar: restaurar ancho original
        sidebar.style.width = sidebarWidth + 'px';
        sidebar.style.padding = '10px';
        sidebar.style.overflow = 'auto';
        tab.style.position = 'fixed';
        tab.style.left = (sidebarWidth - 36) + 'px';
        tab.style.top = '70px';
        tab.style.width = '36px';
        tab.textContent = '☰';
        console.log('Sidebar visible');
      }
    }

    // Event listener del toggle
    sidebarToggleTab.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();
      sidebarIsHidden = !sidebarIsHidden;
      console.log('Toggle clicked. Sidebar ahora oculto:', sidebarIsHidden);
      updateSidebarState();
      
      // Actualizar mapa tras transición
      setTimeout(() => {
        if (map && map.invalidateSize) {
          map.invalidateSize();
        }
      }, 350);
    });

    // Reposicionar en resize
    let resizeTimer;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(updateSidebarState, 100);
    });
    
    sidebarToggleTab.hasListener = true;
    // Inicializar al cargar
    setTimeout(updateSidebarState, 100);
  }

  // ========== CONTROLES MAPA: LEYENDA Y TOGGLE PUNTOS ==========
  function createMapControls() {
    // Leyenda
    if (!legendControl) {
      legendControl = L.control({ position: 'topright' });
      legendControl.onAdd = function(map) {
        var div = L.DomUtil.create('div', 'info legend');
        div.id = 'mapLegend';
        div.style.background = 'white';
        div.style.padding = '6px';
        div.style.boxShadow = '0 0 6px rgba(0,0,0,0.3)';
        div.innerHTML = '<b>Solicitudes</b><br>Cargando...';
        L.DomEvent.disableClickPropagation(div);
        return div;
      };
      legendControl.addTo(map);
    }

    // Toggle puntos (icono estilo "ojo")
    if (!puntosToggleControl) {
      puntosToggleControl = L.control({ position: 'topright' });
      puntosToggleControl.onAdd = function(map) {
        var div = L.DomUtil.create('div', 'info toggle');
        div.style.background = 'white';
        div.style.padding = '4px';
        div.style.marginTop = '6px';
        div.style.boxShadow = '0 0 6px rgba(0,0,0,0.15)';
        var btn = document.createElement('button');
        btn.id = 'btnTogglePuntos';
        btn.title = 'Mostrar / Ocultar puntos';
        btn.style.border = 'none';
        btn.style.background = 'transparent';
        btn.style.cursor = 'pointer';
        btn.style.fontSize = '18px';
        btn.style.lineHeight = '1';
        btn.innerHTML = '👁️';
        div.appendChild(btn);
        L.DomEvent.disableClickPropagation(div);

        btn.addEventListener('click', function() {
          showPuntos = !showPuntos;
          if (showPuntos) {
            if (puntosLayer && !map.hasLayer(puntosLayer)) map.addLayer(puntosLayer);
            btn.style.opacity = '1';
          } else {
            if (map.hasLayer(puntosLayer)) map.removeLayer(puntosLayer);
            btn.style.opacity = '0.4';
          }
        });

        return div;
      };
      puntosToggleControl.addTo(map);
    }
  }

  function updateLegend(breaks) {
    var div = document.getElementById('mapLegend');
    if (!div) return;
    if (!breaks || breaks.length === 0) {
      div.innerHTML = '<b>Solicitudes</b><br>No hay datos';
      return;
    }
    var html = '<b>Solicitudes</b><br>';
    for (var i = 0; i < breaks.length; i++) {
      var min = (i === 0) ? 1 : (breaks[i - 1] + 1);
      var max = breaks[i];
      var color = classColor(i);
      html += '<div style="display:flex;align-items:center;margin-bottom:4px"><span style="width:16px;height:12px;background:' + color + ';display:inline-block;margin-right:6px;border:1px solid #555"></span><span>' + min + ' - ' + max + '</span></div>';
    }
    div.innerHTML = html;
  }

  // Mostrar aviso de rotación SOLO en dispositivos móviles / pantallas estrechas y en orientación vertical
  function checkOrientation() {
    const rotateDiv = document.getElementById('rotateMessage');
    if (!rotateDiv) return;
    // Mostrar aviso SOLO en pantallas pequeñas (móviles). Evitar mostrar en equipos de escritorio táctiles.
    const isMobileWidth = window.innerWidth <= 768;
    if (isMobileWidth && window.innerHeight > window.innerWidth) {
      rotateDiv.style.display = 'flex';
    } else {
      rotateDiv.style.display = 'none';
    }
    // Reposicionar la pestaña toggle si existe
    try { if (typeof positionToggleTab === 'function') positionToggleTab(); } catch(e){}
    
    // IMPORTANTE: Recalcular isMobile y refrescar mapa al cambiar orientación
    const wasTablet = isMobile;
    isMobile = window.innerWidth <= 768;
    
    if (wasTablet !== isMobile) {
      console.log('📱 Orientación cambiada. isMobile ahora:', isMobile);
      // Refrescar el mapa para que se ajuste correctamente
      if (map && map.invalidateSize) {
        setTimeout(() => {
          map.invalidateSize();
          console.log('✅ Mapa redimensionado');
        }, 100);
      }
      // Redrawing charts con nuevo tamaño
      if (chartTipos) chartTipos.resize();
      if (chartColonias) chartColonias.resize();
      if (chartEstados) chartEstados.resize();
    }
  }
  
  window.addEventListener('resize', checkOrientation);
  window.addEventListener('orientationchange', checkOrientation);
  window.addEventListener('load', checkOrientation);

  // ========== REGISTRAR SERVICE WORKER PARA PWA ==========
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('./sw.js')
        .then(reg => console.log('✅ Service Worker registrado:', reg.scope))
        .catch(err => console.log('❌ Error registrando Service Worker:', err));
    });
  }

</script>

</body>
</html>
