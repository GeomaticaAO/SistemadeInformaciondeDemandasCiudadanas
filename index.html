<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Geoportal Solicitudes Ciudadanas</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <!-- PWA Configuration -->
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#922B21">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Geoportal">
  <link rel="apple-touch-icon" href="img/logo/logo.png">

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

  <!-- Leaflet MarkerCluster -->
  <script src="https://unpkg.com/leaflet.markercluster/dist/leaflet.markercluster.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.Default.css" />

  <!-- Bootstrap -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2"></script>

  <!-- SheetJS -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>

  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>

  <!-- Proj4js para transformación de coordenadas -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.9.0/proj4.js"></script>

<style>
  /* Base */
  body { margin:0; font-family:'Montserrat', sans-serif; }
  .navbar { background-color:#6d1f18; color:#fff; }
  .navbar-brand span { color:#fff; font-weight:600; }

  /* Layout principal */
  .main-container {
    display:flex;
    height:calc(100vh - 60px);
    margin-top:60px;
    position: relative;
    overflow: hidden; /* Ocultar cualquier contenido que salga del contenedor */
  }

  /* Sidebar */
  #sidebar {
    width:700px;
    background:#f5f5f5;
    padding:10px;
    overflow-y:auto;
    position: relative;
    transition: all 0.35s ease; /* Animar cambios */
    flex-shrink: 0; /* No reducir el sidebar */
  }

  /* Mapa */
  #map { 
    flex:1; 
    width: 100%;
    min-width: 0; /* Permitir que el mapa se comprima si es necesario */
  }
  canvas { margin-bottom:20px; }

  /* Pestaña de toggle (posicionada dinámicamente por JS) */
  #sidebarToggleTab {
    background: #922B21;
    color: #fff;
    padding: 8px 10px;
    font-size: 16px;
    cursor: pointer;
    z-index: 1001;
    border-radius: 0 4px 4px 0;
    user-select: none;
    border: none;
  }

  .sidebar-title {
    font-size: 12px;
    margin-top: 10px;
    margin-bottom: 8px;
  }

  .tabla-resumen table {
    font-size: 10px;
    border-collapse: collapse;
    width: 100%;
  }
  
  .tabla-resumen table th {
    text-align: center;
    vertical-align: middle;
    background-color: #f8f9fa;
    border: 1px solid #dee2e6;
    padding: 6px 4px;
    font-size: 9px;
  }
  
  .tabla-resumen table td {
    border: 1px solid #dee2e6;
    padding: 4px 6px;
  }

  .chart-container {
    height: 250px;
    position: relative;
    margin-bottom: 15px;
  }

  /* Contenedor específico para gráfica de colonias (más alto para mostrar todos los nombres) */
  #chartColonias {
    max-height: 450px !important;
  }

  /* Loading overlay */
  #loadingOverlay {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.45);
    z-index: 3000;
    display: flex;
    align-items: center;
    justify-content: center;
    color: #fff;
  }
  #loadingOverlay .box {
    background: rgba(0,0,0,0.7);
    padding: 12px 18px;
    border-radius: 6px;
    font-size: 16px;
    font-weight: 600;
  }

  /* Estilos para datalist en móviles */
  datalist, datalist option {
    background: white;
    color: black;
    padding: 8px;
  }
  datalist option {
    padding: 8px;
    background: white;
    color: black;
  }

  /* Autocompletado (fallback móvil) */
  .input-group { position: relative; }
  .autocomplete-list {
    position: absolute;
    top: 100%;
    left: 0;
    right: 0;
    max-height: 240px;
    overflow-y: auto;
    background: #fff;
    border: 1px solid #ccc;
    border-top: none;
    z-index: 3000;
    box-shadow: 0 4px 10px rgba(0,0,0,0.08);
  }
  .autocomplete-item {
    padding: 8px 10px;
    cursor: pointer;
    font-size: 14px;
    line-height: 1.2;
  }
  .autocomplete-item:hover { background: #f3f3f3; }

  /* Modal tabla ciudadanos */
  #modalCiudadanos {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.6);
    z-index: 4000;
    overflow: auto;
  }
  #modalCiudadanos .modal-content {
    background: white;
    margin: 40px auto;
    padding: 20px;
    max-width: 900px;
    border-radius: 8px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.3);
  }
  #modalCiudadanos .modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
    border-bottom: 2px solid #922B21;
    padding-bottom: 10px;
  }
  #modalCiudadanos .close-btn {
    background: #922B21;
    color: white;
    border: none;
    padding: 6px 12px;
    border-radius: 4px;
    cursor: pointer;
    font-weight: 600;
  }
  #modalCiudadanos .close-btn:hover { background: #6d1f18; }
  
  /* Pestañas de navegación */
  .tabs-container {
    display: flex;
    gap: 8px;
    margin-bottom: 15px;
    border-bottom: 2px solid #ddd;
  }
  .tab-btn {
    background: #f5f5f5;
    border: none;
    padding: 10px 20px;
    cursor: pointer;
    font-family: 'Montserrat', sans-serif;
    font-size: 13px;
    font-weight: 600;
    color: #555;
    border-radius: 4px 4px 0 0;
    transition: all 0.2s;
  }
  .tab-btn:hover { background: #e0e0e0; }
  .tab-btn.active {
    background: #922B21;
    color: white;
  }
  .tab-content {
    display: none;
  }
  .tab-content.active {
    display: block;
  }
  
  .tabla-ciudadanos {
    width: 100%;
    font-size: 11px;
    border-collapse: collapse;
  }
  .tabla-ciudadanos th {
    background-color: #922B21;
    color: white;
    text-align: center;
    padding: 8px 6px;
    border: 1px solid #ddd;
  }
  .tabla-ciudadanos td {
    padding: 6px 8px;
    border: 1px solid #ddd;
    text-align: left;
  }
  .tabla-ciudadanos tr:hover { background-color: #f5f5f5; }
  
  .toggle-row {
    user-select: none;
  }
  .toggle-row:hover { background-color: #f5f5f5; }
  .toggle-icon {
    display: inline-block;
    width: 16px;
    font-weight: bold;
    text-align: center;
  }
  .detail-row {
    display: none;
    background-color: #fafafa;
  }
  .detail-row.show { display: table-row; }
  .detail-content {
    padding: 10px 20px;
    font-size: 10px;
  }
  .detail-table {
    width: 100%;
    margin-top: 5px;
  }
  .detail-table th {
    background-color: #e9ecef;
    padding: 4px 6px;
    text-align: left;
    border: 1px solid #ccc;
  }
  .detail-table td {
    padding: 3px 6px;
    border: 1px solid #ddd;
  }
  
  /* Selección de celdas estilo Excel */
  .tabla-ciudadanos td.selected,
  .detail-table td.selected {
    background-color: #d1e7fd !important;
    outline: 2px solid #0d6efd;
  }
  
  .stats-bar {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    background: #922B21;
    color: white;
    padding: 8px 20px;
    font-family: 'Montserrat', sans-serif;
    font-size: 12px;
    font-weight: 600;
    z-index: 5000;
    display: none;
    box-shadow: 0 -2px 10px rgba(0,0,0,0.2);
  }
  
  .stats-bar span {
    margin-right: 20px;
  }
</style>
</head>
<body>

  <!-- Encabezado -->
  <nav class="navbar navbar-expand-lg fixed-top">
    <div class="container-fluid">
      <a class="navbar-brand" href="#">
        <img src="img/logo/logo.png" alt="logo" style="height:40px;">
        <span>Solicitudes Ciudadanas - Alcaldía Álvaro Obregón</span>
      </a>
    </div>
  </nav>

  <!-- Aviso para móviles: girar el celular -->
  <div id="rotateMessage" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.7);z-index:2000;display:flex;align-items:center;justify-content:center;color:#fff;">
    <div style="text-align:center;padding:20px;max-width:320px;margin:auto;">
      <div style="font-size:28px;margin-bottom:10px;">↪️</div>
      <div style="font-size:18px;font-weight:600;">Gire su dispositivo</div>
      <div style="margin-top:8px;font-size:14px;">Para una mejor visualización, use el modo horizontal.</div>
    </div>
  </div>

  <!-- Overlay de carga -->
  <div id="loadingOverlay"><div class="box">Cargando datos</div></div>

  <!-- Modal Tabla Ciudadanos -->
  <div id="modalCiudadanos">
    <div class="modal-content">
      <div class="modal-header">
        <h3 style="margin:0; color:#922B21; font-family:'Montserrat', sans-serif;">Análisis de Solicitudes</h3>
        <button class="close-btn" id="btnCerrarModal">Cerrar</button>
      </div>
      
      <!-- Pestañas -->
      <div class="tabs-container">
        <button class="tab-btn active" data-tab="tab-ciudadanos">Por Ciudadano</button>
        <button class="tab-btn" data-tab="tab-tipos">Por Tipo de Solicitud</button>
      </div>
      
      <!-- Contenido Pestaña 1: Por Ciudadano -->
      <div id="tab-ciudadanos" class="tab-content active">
        <div id="contenidoTablaCiudadanos" style="max-height: 65vh; overflow-y: auto;"></div>
      </div>
      
      <!-- Contenido Pestaña 2: Por Tipo -->
      <div id="tab-tipos" class="tab-content">
        <div id="contenidoTablaTipos" style="max-height: 65vh; overflow-y: auto;"></div>
      </div>
    </div>
  </div>

  <!-- Contenedor principal -->
  <div class="main-container">

    <!-- Pestaña flotante de toggle (fuera del sidebar para evitar conflictos de posicionamiento) -->
    <div id="sidebarToggleTab">☰</div>

    <!-- Sidebar -->
    <div id="sidebar">
      <h4 class="sidebar-title">Buscar por folio o colonia</h4>
      <div class="input-group mb-3">
        <input type="text" id="buscadorGeneral" class="form-control" placeholder="Ingrese folio o colonia" autocomplete="off">
        <datalist id="sugerenciasColonias" style="display:none;"></datalist>
        <button class="btn btn-primary btn-sm" id="btnBuscarGeneral">Buscar</button>
        <button class="btn btn-secondary btn-sm" id="btnResetBuscar">Limpiar</button>
      </div>

      <button class="btn btn-sm mb-3" id="btnVerCiudadanos" style="background-color:#922B21; color:white; font-weight:600;">Ver Análisis</button>

      <h4 class="sidebar-title">Filtrar por tipo</h4>
      <select id="filtroTipo" class="form-select mb-3">
        <option value="Todos">Todos</option>
      </select>

      <h4 class="sidebar-title">Filtrar por estado</h4>
      <select id="filtroEstado" class="form-select mb-3">
        <option value="Todos">Todos</option>
      </select>

      <h4 class="sidebar-title">Filtrar por mes</h4>
      <select id="filtroMes" class="form-select mb-3">
        <option value="Todos">Todos</option>
      </select>

      <button class="btn btn-sm mb-3" id="btnAplicarFiltros" style="background-color:#922B21; color:white; font-weight:600;">Aplicar filtros</button>

      <div id="contadorSolicitudes" style="text-align:center; font-family:'Montserrat', sans-serif; font-size:14px; font-weight:600; color:#922B21; margin-bottom:15px; line-height:1.4;">
        Total de solicitudes: <span id="totalSolicitudes">0</span>
      </div>

      <h4 class="sidebar-title">Estadísticas</h4>
      <div class="chart-container">
        <canvas id="chartMesesEstados"></canvas>
      </div>
      <div class="chart-container">
        <canvas id="chartTipos"></canvas>
      </div>
      <div class="chart-container">
        <canvas id="chartColonias"></canvas>
      </div>
      <div class="chart-container">
        <canvas id="chartEstados"></canvas>
      </div>

      <h4 class="sidebar-title">Tabla resumen</h4>
      <div id="tablaResumen" class="tabla-resumen"></div>
    </div>

    <!-- Mapa -->
    <div id="map"></div>
  </div>

  <!-- Barra de estadísticas (estilo Excel) -->
  <div id="statsBar" class="stats-bar">
    <span>Recuento: <span id="statCount">0</span></span>
    <span>Suma: <span id="statSum">0</span></span>
    <span>Promedio: <span id="statAvg">0</span></span>
  </div>

<script>
  // ========== VARIABLES GLOBALES ==========
  // Detectar si es móvil (RECALCULAR dinámicamente)
  let isMobile = window.innerWidth <= 768;
  
  // Declaraciones e inicialización de variables globales usadas en el script
  var map;
  var coloniasLayer = null;
  var vialidadesLayer = null;
  var solicitudesGeoJSON = null;
  var solicitudes = [];
  var solicitudPorId = {};
  var allIds = [];
  var indiceTipo = {};
  var indiceEstado = {};
  var indiceMes = {};
  var estadisticasPorColonia = {};
  var puntosLayer = null;
  var legendControl = null;
  var puntosToggleControl = null;
  var chartTipos = null, chartColonias = null, chartEstados = null, chartMesesEstados = null;
  var showPuntos = true;
  var zoomendHandlerAdded = false;
  var coloniaSeleccionada = null;
  var selectedOutline = null;
  var normToColoniaName = {};
  var lastTipoForTable = null;
  
  // Lista de colonias para autocompletado (fallback móvil)
  var coloniasList = [];
  var autocompleteContainer = null;
  
  // Caché para tablas ya generadas
  var tablasGeneradas = {
    ciudadanos: false,
    tipos: false
  };
  
  // ✅ NUEVA OPTIMIZACIÓN: Índice espacial para matching rápido de coordenadas
  var coordIndexMap = new Map(); // Clave: "lon,lat" -> array de IDs

  // Inicializar el mapa antes de cargar capas y datos
  try {
    map = L.map('map').setView([19.35, -99.2], 13);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);
    

  } catch (e) {
    console.error('Error inicializando mapa:', e);
  }

  function generarTablaResumen(datos){
    // Mantener la función original por compatibilidad si hace falta
    let resumen = {};
    datos.forEach(s => {
      if(!s["Fecha reporte"] || !s["Estado Reporte"]) return;
      let fecha = new Date(s["Fecha reporte"]);
      if(isNaN(fecha)) return;

      let mesClave = fecha.getFullYear()+"-"+(fecha.getMonth()+1).toString().padStart(2,"0");
      if(!resumen[mesClave]) {
        resumen[mesClave] = { Atendido:0, Pendiente:0, "En atención":0, "No compete":0 };
      }

      let estado = s["Estado Reporte"].trim();
      if(estado==="Pendiente") resumen[mesClave].Pendiente++;
      else if(estado==="En atención") resumen[mesClave]["En atención"]++;
      else if(estado==="Atendido") resumen[mesClave].Atendido++;
      else if(estado==="No compete") resumen[mesClave]["No compete"]++;
    });

    let mesesOrdenados = Object.keys(resumen).sort();
    let tabla = `<table class="table table-striped"><thead><tr>
      <th>Mes</th><th>Atendido</th><th>Pendiente</th><th>En atención</th><th>No compete</th>
    </tr></thead><tbody>`;
    let totales = { Atendido: 0, Pendiente: 0, "En atención": 0, "No compete": 0 };
    mesesOrdenados.forEach(m => {
      const r = resumen[m];
      const [anio, mesNum] = m.split("-");
      let nombreMes = new Date(anio, parseInt(mesNum) - 1).toLocaleString('es-ES', { month: 'long' });
      nombreMes = nombreMes.charAt(0).toUpperCase() + nombreMes.slice(1);
      tabla += `<tr>
        <td>${nombreMes} ${anio}</td>
        <td>${r.Atendido}</td>
        <td>${r.Pendiente}</td>
        <td>${r["En atención"]}</td>
        <td>${r["No compete"]}</td>
      </tr>`;
      Object.keys(totales).forEach(k => { totales[k] += r[k]; });
    });
    tabla += `<tr style="font-weight:bold;">
      <td>Total</td>
      <td>${totales.Atendido}</td>
      <td>${totales.Pendiente}</td>
      <td>${totales["En atención"]}</td>
      <td>${totales["No compete"]}</td>
    </tr></tbody></table>`;
    document.getElementById("tablaResumen").innerHTML = tabla;
  }

  // Generar tabla estática: Top 10 colonias y Últimas 10 solicitudes según filtro Tipo
  function generarTablaEstatica(tipo) {
    // Filtrar por tipo (o todos)
    const filtradasPorTipo = solicitudes.filter(s => {
      if (!s) return false;
      if (tipo === 'Todos' || !tipo) return true;
      return s["Tipo de reporte"] === tipo;
    });

    // Top 10 colonias
    const conteoCol = {};
    filtradasPorTipo.forEach(s => {
      const col = s["Colonia"] || 'Sin colonia';
      conteoCol[col] = (conteoCol[col] || 0) + 1;
    });
    const topColonias = Object.entries(conteoCol)
      .map(([col, cnt]) => ({col, cnt}))
      .sort((a,b) => b.cnt - a.cnt)
      .slice(0,10);

    // Últimas 10 solicitudes (por fecha)
    const ultimasSolicitudes = filtradasPorTipo
      .filter(s => s["Fecha reporte"])
      .map(s => ({
        folio: s["Número folio"],
        fecha: new Date(s["Fecha reporte"]),
        colonia: s["Colonia"] || 'Sin colonia',
        ciudadano: s["Nombre Ciudadano"] || 'N/A',
        telefono: s["Teléfono"] || 'N/A',
        tipo: s["Tipo de reporte"] || 'N/A',
        estado: s["Estado Reporte"] || 'N/A',
        referencia: s["Punto de referencia"] || 'N/A'
      }))
      .filter(x => !isNaN(x.fecha))
      .sort((a,b) => b.fecha - a.fecha)
      .slice(0,10);

    // Construir HTML
    let html = '<div style="display:flex;flex-direction:column;gap:12px">';

    // Top Colonias
    html += '<div><b>Top 10 Colonias (por número de solicitudes)</b>';
    html += '<table class="table table-sm"><thead><tr><th>Colonia</th><th>Total</th></tr></thead><tbody>';
    topColonias.forEach(c => {
      html += `<tr><td>${c.col}</td><td>${c.cnt}</td></tr>`;
    });
    if (topColonias.length === 0) html += '<tr><td colspan="2">No hay datos</td></tr>';
    html += '</tbody></table></div>';

    // Últimas solicitudes
    html += '<div><b>Últimas 10 Solicitudes</b>';
    html += '<table class="table table-sm"><thead><tr><th>Folio</th><th>Fecha</th><th>Colonia</th><th>Ciudadano</th><th>Teléfono</th><th>Tipo</th><th>Estado</th></tr></thead><tbody>';
    ultimasSolicitudes.forEach(s => {
      html += `<tr><td>${s.folio}</td><td>${s.fecha.toLocaleString()}</td><td>${s.colonia}</td><td>${s.ciudadano}</td><td>${s.telefono}</td><td>${s.tipo}</td><td>${s.estado}</td></tr>`;
    });
    if (ultimasSolicitudes.length === 0) html += '<tr><td colspan="7">No hay solicitudes</td></tr>';
    html += '</tbody></table></div>';

    html += '</div>';
    document.getElementById('tablaResumen').innerHTML = html;
  }

  function classColor(i){
    const colors = ['#DBD8D7','#FAEAE3','#FD9D8C','#F72F35','#99250F','#4A0E03'];
    return colors[Math.min(Math.max(i,0), colors.length-1)];
  }

  function getJenksBreaks(data, numClasses) {
    data = data.filter(v => !isNaN(v)).sort((a, b) => a - b);
    if (data.length === 0) return [];

    let matrices = [], variance = [];
    for (let i = 0; i < data.length + 1; i++) {
      let tmp1 = [], tmp2 = [];
      for (let j = 0; j < numClasses + 1; j++) { tmp1.push(0); tmp2.push(0); }
      matrices.push(tmp1); variance.push(tmp2);
    }

    for (let i = 1; i < numClasses + 1; i++) {
      matrices[0][i] = 1; variance[0][i] = 0;
      for (let j = 1; j < data.length + 1; j++) { variance[j][i] = Infinity; }
    }

    for (let l = 2; l < data.length + 1; l++) {
      let sum = 0, sumSquares = 0, w = 0;
      for (let m = 1; m < l + 1; m++) {
        let i3 = l - m + 1, val = data[i3 - 1];
        w++; sum += val; sumSquares += val * val;
        let varianceVal = sumSquares - (sum * sum) / w;
        let i4 = i3 - 1;
        if (i4 !== 0) {
          for (let j = 2; j < numClasses + 1; j++) {
            if (variance[l][j] >= (varianceVal + variance[i4][j - 1])) {
              variance[l][j] = varianceVal + variance[i4][j - 1];
              matrices[l][j] = i3;
            }
          }
        }
      }
      variance[l][1] = sumSquares - (sum * sum) / w;
      matrices[l][1] = 1;
    }

    let k = data.length, kclass = [];
    for (let j = numClasses; j > 0; j--) {
      let id = matrices[k][j] - 1;
      kclass.push(data[id]);
      k = matrices[k][j] - 1;
    }
    kclass.push(data[data.length - 1]);
    return kclass.reverse();
  }

  // Normalizar cadenas: trim, mayúsculas, eliminar tildes/diacríticos, quitar signos
  function normalizeKey(s) {
    if (s === undefined || s === null) return null;
    try {
      return String(s)
        .trim()
        .toUpperCase()
        .normalize('NFD')
        .replace(/[\u0000-\u001F\u007F]/g, '')
        .replace(/[\u0300-\u036f]/g, '')
        .replace(/[^A-Z0-9\s]/g, '')
        .replace(/\s+/g, ' ');
    } catch (e) {
      return String(s).trim().toUpperCase();
    }
  }

  // ✅ NUEVA OPTIMIZACIÓN: Simplificar geometrías de polígonos para reducir vértices
  function simplifyGeometry(coords, tolerance = 0.001) {
    if (!coords || coords.length < 3) return coords;
    // Douglas-Peucker simplificado para reducir puntos en polígonos
    const simplified = [];
    const len = coords.length;
    // Siempre mantener primer y último punto
    simplified.push(coords[0]);
    // Tomar cada N puntos (más agresivo en móviles)
    const step = isMobile ? 3 : 2;
    for (let i = step; i < len - 1; i += step) {
      simplified.push(coords[i]);
    }
    simplified.push(coords[len - 1]);
    return simplified;
  }

  // ✅ NUEVA OPTIMIZACIÓN: Debounce para evitar múltiples renders rápidos
  function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
      const later = () => {
        clearTimeout(timeout);
        func(...args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  }

  // ========== OBTENER IDs FILTRADOS ==========
  // Obtener IDs filtrados; si ignoreColonia=true, se omite el filtro por coloniaSeleccionada
  function obtenerIdsFiltrados(filtroTipo, filtroEstado, filtroMes, ignoreColonia = false) {
    let setIds = new Set(allIds);

    if (filtroTipo !== "Todos") {
      setIds = new Set(indiceTipo[filtroTipo] || []);
    }
    if (filtroEstado !== "Todos") {
      const idsEstado = new Set(indiceEstado[filtroEstado] || []);
      setIds = new Set([...setIds].filter(id => idsEstado.has(id)));
    }
    if (filtroMes !== "Todos") {
      const idsMes = new Set(indiceMes[filtroMes] || []);
      setIds = new Set([...setIds].filter(id => idsMes.has(id)));
    }
    if (!ignoreColonia && coloniaSeleccionada) {
      const nombreColonia = coloniaSeleccionada.feature?.properties?.NOMBRE;
      const nombreNorm = normalizeKey(nombreColonia);
      setIds = new Set([...setIds].filter(id => solicitudPorId[id]["ColoniaNorm"] === nombreNorm));
    }
    return [...setIds];
  }

  // ========== LOADING OVERLAY HELPERS ==========
  function showLoading() {
    try {
      const d = document.getElementById('loadingOverlay');
      if (d) d.style.display = 'flex';
    } catch (e) { console.log('showLoading error', e); }
  }
  function hideLoading() {
    try {
      const d = document.getElementById('loadingOverlay');
      if (d) d.style.display = 'none';
    } catch (e) { console.log('hideLoading error', e); }
  }

  // ========== PRECÁLCULO DE ÍNDICES Y ESTADÍSTICAS ==========
  function precalcularIndices() {
    solicitudPorId = {};
    allIds = [];
    indiceTipo = {};
    indiceEstado = {};
    indiceMes = {};
    estadisticasPorColonia = {};
  coordIndexMap.clear(); // Limpiar índice espacial

    solicitudes.forEach((s, idx) => {
      s._id = idx;
      solicitudPorId[idx] = s;
      allIds.push(idx);

      // ✅ NUEVA OPTIMIZACIÓN: Construir índice espacial
      const lon = Number(s["Coordenada X"]);
      const lat = Number(s["Coordenada Y"]);
      if (!isNaN(lon) && !isNaN(lat)) {
        // Redondear a 6 decimales para agrupación (~10cm precisión)
        const key = `${lon.toFixed(6)},${lat.toFixed(6)}`;
        if (!coordIndexMap.has(key)) coordIndexMap.set(key, []);
        coordIndexMap.get(key).push(idx);
      }

      const tipo = s["Tipo de reporte"] || "Sin tipo";
        console.log('✅ Índice espacial construido con', coordIndexMap.size, 'ubicaciones únicas');
      if (!indiceTipo[tipo]) indiceTipo[tipo] = [];
      indiceTipo[tipo].push(idx);

      const estado = s["Estado Reporte"] || "Sin estado";
      if (!indiceEstado[estado]) indiceEstado[estado] = [];
      indiceEstado[estado].push(idx);

      if (s["Fecha reporte"]) {
        const fecha = new Date(s["Fecha reporte"]);
        if (!isNaN(fecha)) {
          const mesNombre = fecha.toLocaleString('es-ES', { month: 'long' });
          if (!indiceMes[mesNombre]) indiceMes[mesNombre] = [];
          indiceMes[mesNombre].push(idx);
        }
      }

      const col = s["Colonia"];
      const colNorm = s["ColoniaNorm"] || normalizeKey(col);
      if (colNorm) {
        if (!estadisticasPorColonia[colNorm]) {
          estadisticasPorColonia[colNorm] = { tipos: {}, estados: {}, meses: {}, originalNames: {} };
        }
        estadisticasPorColonia[colNorm].tipos[tipo] = (estadisticasPorColonia[colNorm].tipos[tipo] || 0) + 1;
        estadisticasPorColonia[colNorm].estados[estado] = (estadisticasPorColonia[colNorm].estados[estado] || 0) + 1;
        if (s["Fecha reporte"] && !isNaN(new Date(s["Fecha reporte"]))) {
          const mesNombre = new Date(s["Fecha reporte"]).toLocaleString('es-ES', { month: 'long' });
          estadisticasPorColonia[colNorm].meses[mesNombre] = (estadisticasPorColonia[colNorm].meses[mesNombre] || 0) + 1;
        }
        // Guardar ejemplos de nombres originales para referencia
        if (col) {
          estadisticasPorColonia[colNorm].originalNames[col] = (estadisticasPorColonia[colNorm].originalNames[col] || 0) + 1;
        }
      }
    });
  }

  // ========== RENDERIZAR FUNCIÓN OPTIMIZADA ==========
  function renderizar(filtroTipo, filtroEstado, filtroMes) {
    // Mostrar overlay de carga al iniciar render
    try { showLoading(); } catch(e){}

    // Prevenir renderizado si no hay datos cargados
    if (!solicitudes || solicitudes.length === 0 || !solicitudesGeoJSON) {
      try { hideLoading(); } catch(e){}
      return;
    }
    
    // ✅ OPTIMIZACIÓN 1: Usar índices precalculados en lugar de .forEach()
    // idsFiltradosRespectCol: respetan la selección de colonia (para puntos)
    const idsFiltradosRespectCol = obtenerIdsFiltrados(filtroTipo, filtroEstado, filtroMes, false);
    // idsFiltradosIgnoreCol: ignoran la selección de colonia (para choropleth, charts y tabla)
    const idsFiltradosIgnoreCol = obtenerIdsFiltrados(filtroTipo, filtroEstado, filtroMes, true);

    // ===== Agregados por colonia basados en los ids filtrados IGNORANDO la selección puntual de colonia =====
    const countsByColNorm = {}; // { norm: { total: n, estados: {estado: n} } }
    idsFiltradosIgnoreCol.forEach(id => {
      const s = solicitudPorId[id];
      if (!s) return;
      const norm = s["ColoniaNorm"] || normalizeKey(s["Colonia"]);
      const estado = s["Estado Reporte"] || 'Sin estado';
      if (!norm) return;
      if (!countsByColNorm[norm]) countsByColNorm[norm] = { total: 0, estados: {} };
      countsByColNorm[norm].total += 1;
      countsByColNorm[norm].estados[estado] = (countsByColNorm[norm].estados[estado] || 0) + 1;
    });
    
    // Contadores para gráficas
    var tipos = {}, estados = {}, fechas = {};

    // Para las métricas de las gráficas usaremos idsFiltradosIgnoreCol (no limitar por la colonia seleccionada)
    idsFiltradosIgnoreCol.forEach(id => {
      const s = solicitudPorId[id];
      if (!s) return;
      const tipo = s["Tipo de reporte"];
      const estado = s["Estado Reporte"];
      const fecha = s["Fecha reporte"] ? new Date(s["Fecha reporte"]) : null;

      if (tipo) tipos[tipo] = (tipos[tipo] || 0) + 1;
      if (estado) {
        if (estado === "Pendiente" || estado === "En atención") {
          estados["Pendiente/En Atención"] = (estados["Pendiente/En Atención"] || 0) + 1;
        } else {
          estados[estado] = (estados[estado] || 0) + 1;
        }
      }
      if (fecha && !isNaN(fecha)) {
        const clave = fecha.getFullYear() + "-" + (fecha.getMonth() + 1).toString().padStart(2, "0");
        fechas[clave] = (fechas[clave] || 0) + 1;
      }
    });

    // ✅ OPTIMIZACIÓN 2: Filtrar GeoJSON una sola vez para los PUNTOS según idsFiltradosRespectCol
    const allowedIds = new Set(idsFiltradosRespectCol);
    const featuresFiltradas = solicitudesGeoJSON.features.filter((f, idx) => {
      if (!f.geometry || f.geometry.type !== "Point" || !Array.isArray(f.geometry.coordinates)) return false;
      
      // ✅ MEJORA: Usar índice espacial para búsqueda rápida
      const lon = f.geometry.coordinates[0];
      const lat = f.geometry.coordinates[1];
      const key = `${lon.toFixed(6)},${lat.toFixed(6)}`;
      const idsEnCoordenada = coordIndexMap.get(key);
      
      if (!idsEnCoordenada) return false;
      
      // Verificar si alguno de los IDs en esta coordenada está en allowedIds
      return idsEnCoordenada.some(id => allowedIds.has(id));
    });

    // ✅ OPTIMIZACIÓN 3: Inicializar capa de puntos UNA SOLA VEZ (sin clustering)
    if (!puntosLayer) {
      puntosLayer = L.layerGroup();
      // No agregar por defecto, solo cuando zoom >= 14

      // ✅ OPTIMIZACIÓN 4: Event listener ÚNICO para zoom
      if (!zoomendHandlerAdded) {
        map.on('zoomend', function() {
          if (!puntosLayer) return;
          // Mostrar puntos solo en zoom >= 16 y si showPuntos está activo
          if (map.getZoom() >= 16 && showPuntos) {
            if (!map.hasLayer(puntosLayer)) map.addLayer(puntosLayer);
          } else {
            if (map.hasLayer(puntosLayer)) map.removeLayer(puntosLayer);
          }
        });
        zoomendHandlerAdded = true;
      }
    }

      // Asegurar control de leyenda y toggle están creados
      if (!legendControl || !puntosToggleControl) createMapControls();

    // ✅ LIMPIAR layers de la capa anterior (sin recrear)
    puntosLayer.clearLayers();

    // ✅ Agregar features filtradas
    const capaGeoJson = L.geoJson(
      { type: "FeatureCollection", features: featuresFiltradas },
      {
        pointToLayer: function (feature, latlng) {
          return L.circleMarker(latlng, {
            radius: 4,
            fillColor: "#F7EC1B",
            color: "#26261C",
            weight: 1,
            opacity: 1,
            fillOpacity: 0.7
          }).bindPopup(`
            <b>Folio:</b> ${feature.properties["Número folio"]}<br>
            <b>Ciudadano:</b> ${feature.properties["Nombre Ciudadano"] || 'N/A'}<br>
            <b>Teléfono:</b> ${feature.properties["Teléfono"] || 'N/A'}<br>
            <b>Tipo:</b> ${feature.properties["Tipo de reporte"]}<br>
            <b>Estado:</b> ${feature.properties["Estado Reporte"]}<br>
            <b>Punto de referencia:</b> ${feature.properties["Punto de referencia"] || 'N/A'}
          `);
        }
      }
    );

    puntosLayer.addLayer(capaGeoJson);
    
    // Mostrar puntos solo si: zoom >= 16 Y showPuntos está activo
    const currentZoom = map.getZoom();
    if (showPuntos && currentZoom >= 16) {
      if (!map.hasLayer(puntosLayer)) map.addLayer(puntosLayer);
      const btn = document.getElementById('btnTogglePuntos'); if (btn) btn.style.opacity = '1';
    } else {
      if (map.hasLayer(puntosLayer)) map.removeLayer(puntosLayer);
      const btn = document.getElementById('btnTogglePuntos'); 
      if (btn) btn.style.opacity = showPuntos ? '1' : '0.4';
    }

    // Fitear solo si hay colonia seleccionada
    if (coloniaSeleccionada && coloniaSeleccionada.getBounds) {
      try {
        map.fitBounds(coloniaSeleccionada.getBounds());
      } catch (e) {
        console.log("Error fitBounds:", e);
      }
    }

    // ========== GRÁFICAS ==========
    const chartLimit = isMobile ? 6 : 10; // En móviles mostrar solo 6 para mejor rendimiento
    function prepararDatos(obj) {
      let arr = Object.entries(obj);
      arr.sort((a, b) => b[1] - a[1]);
      arr = arr.slice(0, chartLimit);
      return {
        labels: arr.map(e => e[0]),
        values: arr.map(e => e[1])
      };
    }

    let datosTipos = prepararDatos(tipos);
    let datosEstados = prepararDatos(estados);

    // Definir colores y orden de estados (para usar en múltiples gráficas)
    const ordenEstados = ["Pendiente", "En atención", "Atendido", "No compete"];
    const coloresEstados = {
      "Pendiente": "#991B02",
      "En atención": "#ED8718",
      "Atendido": "#0BC700",
      "No compete": "#545454"
    };

    // ========== GRÁFICA MESES Y ESTADOS ==========
    // Agrupar solicitudes por mes y estado
    const mesesEstados = {};
    const nombresMeses = ['enero', 'febrero', 'marzo', 'abril', 'mayo', 'junio', 
                          'julio', 'agosto', 'septiembre', 'octubre', 'noviembre', 'diciembre'];
    
    idsFiltradosIgnoreCol.forEach(id => {
      const s = solicitudPorId[id];
      if (!s || !s["Fecha reporte"]) return;
      
      const fecha = new Date(s["Fecha reporte"]);
      if (isNaN(fecha)) return;
      
      const mesNombre = nombresMeses[fecha.getMonth()];
      const estado = s["Estado Reporte"] || 'Sin estado';
      
      if (!mesesEstados[mesNombre]) {
        mesesEstados[mesNombre] = {};
      }
      mesesEstados[mesNombre][estado] = (mesesEstados[mesNombre][estado] || 0) + 1;
    });

    // Ordenar meses por orden cronológico (basado en datos disponibles)
    const mesesOrdenados = nombresMeses.filter(mes => mesesEstados[mes]);
    const totalsPorMes = mesesOrdenados.map(mes => 
      Object.values(mesesEstados[mes] || {}).reduce((a, b) => a + b, 0)
    );

    const datasetsMeses = ordenEstados.map(est => ({
      label: est,
      data: mesesOrdenados.map(mes => mesesEstados[mes][est] || 0),
      backgroundColor: coloresEstados[est] || "#999"
    }));

    if (chartMesesEstados) {
      chartMesesEstados.data.labels = mesesOrdenados.map(m => m.charAt(0).toUpperCase() + m.slice(1));
      chartMesesEstados.data.datasets = datasetsMeses;
      chartMesesEstados.data.totals = totalsPorMes;
      chartMesesEstados.update(isMobile ? 'none' : 'none');
    } else {
      chartMesesEstados = new Chart(document.getElementById('chartMesesEstados'), {
        type: 'bar',
        data: {
          labels: mesesOrdenados.map(m => m.charAt(0).toUpperCase() + m.slice(1)),
          datasets: datasetsMeses,
          totals: totalsPorMes
        },
        options: {
          indexAxis: 'y',
          responsive: true,
          maintainAspectRatio: false,
          animation: { duration: 0 },
          layout: { padding: { right: 50 } },
          plugins: {
            title: {
              display: true,
              text: 'Solicitudes por Mes y Estado',
              font: { size: 14, weight: 'bold' },
              color: '#922B21',
              padding: { bottom: 10 }
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  const total = context.chart.data.totals[context.dataIndex];
                  const valor = context.raw;
                  return `${context.dataset.label}: ${valor} de ${total}`;
                }
              }
            },
            legend: { position: 'bottom', labels: { font: { size: 10 } } },
            datalabels: {
              display: function(context) {
                // Solo mostrar en el último segmento (No compete)
                return context.datasetIndex === context.chart.data.datasets.length - 1;
              },
              anchor: 'end',
              align: 'end',
              formatter: function(value, context) {
                const total = context.chart.data.totals[context.dataIndex];
                return total.toLocaleString('es-MX');
              },
              color: '#333',
              font: { weight: 'bold', size: 10 }
            }
          },
          scales: {
            x: { stacked: true, ticks: { precision: 0 } },
            y: {
              stacked: true,
              ticks: { font: { size: 9 } },
              maxRotation: 0,
              minRotation: 0,
              categoryPercentage: 0.7,
              barPercentage: 0.8
            }
          }
        },
        plugins: [ChartDataLabels]
      });
    }

    // Gráfica Tipos
    if (chartTipos) {
      chartTipos.data.labels = datosTipos.labels;
      chartTipos.data.datasets[0].data = datosTipos.values;
      chartTipos.update(isMobile ? 'none' : 'none');
    } else {
      chartTipos = new Chart(document.getElementById('chartTipos'), {
        type: 'bar',
        data: {
          labels: datosTipos.labels,
          datasets: [{
            label: 'Solicitudes por tipo',
            data: datosTipos.values,
            backgroundColor: '#922B21'
          }]
        },
        options: {
          indexAxis: 'y',
          responsive: true,
          maintainAspectRatio: false,
          animation: { duration: isMobile ? 0 : 0 },
          layout: { padding: { right: 50 } },
          plugins: {
            title: {
              display: true,
              text: 'Solicitudes por Tipo de Reporte',
              font: { size: 14, weight: 'bold' },
              color: '#922B21',
              padding: { bottom: 10 }
            },
            legend: { display: false },
            datalabels: {
              anchor: 'end',
              align: 'end',
              formatter: (value) => value.toLocaleString('es-MX'),
              color: '#333',
              font: { weight: 'bold', size: 11 }
            }
          },
          scales: {
            x: { ticks: { precision: 0 } },
            y: {
              ticks: { font: { size: 10 } },
              categoryPercentage: 0.7,
              barPercentage: 0.8
            }
          }
        },
        plugins: [ChartDataLabels]
      });
    }

    // Gráfica Colonias (usar countsByColNorm calculados desde idsFiltrados)
    const conteoColoniasEstados = {};
    Object.entries(countsByColNorm).forEach(([colNorm, info]) => {
      const displayName = normToColoniaName[colNorm] || (estadisticasPorColonia[colNorm] && Object.keys(estadisticasPorColonia[colNorm].originalNames || {})[0]) || colNorm;
      conteoColoniasEstados[displayName] = info.estados || {};
      conteoColoniasEstados[displayName]._total = info.total || 0;
    });

    let coloniasOrdenadas = Object.entries(conteoColoniasEstados)
      .map(([colonia, estados]) => {
        const total = estados._total || Object.values(estados).reduce((a, b) => a + b, 0);
        // remove _total from estados copy
        const estadosCopy = Object.assign({}, estados);
        delete estadosCopy._total;
        return { colonia, estados: estadosCopy, total };
      })
      .sort((a, b) => b.total - a.total)
      .slice(0, chartLimit);

    const labelsColonias = coloniasOrdenadas.map(c => c.colonia);
    const totalsColonias = coloniasOrdenadas.map(c => c.total);

    const datasetsColonias = ordenEstados.map(est => ({
      label: est,
      data: coloniasOrdenadas.map(c => c.estados[est] || 0),
      backgroundColor: coloresEstados[est] || "#999"
    }));

    if (chartColonias) {
      chartColonias.data.labels = labelsColonias;
      chartColonias.data.datasets = datasetsColonias;
      chartColonias.data.totals = totalsColonias;
      chartColonias.update(isMobile ? 'none' : 'none');
    } else {
      chartColonias = new Chart(document.getElementById('chartColonias'), {
        type: 'bar',
        data: {
          labels: labelsColonias,
          datasets: datasetsColonias,
          totals: totalsColonias
        },
        options: {
          indexAxis: 'y',
          responsive: true,
          maintainAspectRatio: false,
          animation: { duration: 0 },
          layout: { padding: { right: 50 } },
          plugins: {
            title: {
              display: true,
              text: 'Solicitudes por Colonia y Estado',
              font: { size: 14, weight: 'bold' },
              color: '#922B21',
              padding: { bottom: 10 }
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  const total = context.chart.data.totals[context.dataIndex];
                  const valor = context.raw;
                  return `${context.dataset.label}: ${valor} de ${total}`;
                }
              }
            },
            legend: { position: 'bottom', labels: { font: { size: 10 } } },
            datalabels: {
              display: function(context) {
                // Solo mostrar en el último segmento (No compete)
                return context.datasetIndex === context.chart.data.datasets.length - 1;
              },
              anchor: 'end',
              align: 'end',
              formatter: function(value, context) {
                const total = context.chart.data.totals[context.dataIndex];
                return total.toLocaleString('es-MX');
              },
              color: '#333',
              font: { weight: 'bold', size: 10 }
            }
          },
          scales: {
            x: { stacked: true, ticks: { precision: 0 } },
            y: {
              stacked: true,
              ticks: { font: { size: 9 } },
              maxRotation: 0,
              minRotation: 0,
              categoryPercentage: 0.7,
              barPercentage: 0.8
            }
          }
        },
        plugins: [ChartDataLabels]
      });
    }

    // Gráfica Estados
    if (chartEstados) {
      chartEstados.data.labels = datosEstados.labels;
      chartEstados.data.datasets[0].data = datosEstados.values;
      chartEstados.update(isMobile ? 'none' : 'none');
    } else {
      chartEstados = new Chart(document.getElementById('chartEstados'), {
        type: 'bar',
        data: {
          labels: datosEstados.labels,
          datasets: [{
            label: 'Solicitudes por estado',
            data: datosEstados.values,
            backgroundColor: '#36a2eb'
          }]
        },
        options: {
          indexAxis: 'y',
          responsive: true,
          maintainAspectRatio: false,
          animation: { duration: isMobile ? 0 : 0 },
          layout: { padding: { right: 50 } },
          plugins: {
            title: {
              display: true,
              text: 'Solicitudes por Estado',
              font: { size: 14, weight: 'bold' },
              color: '#922B21',
              padding: { bottom: 10 }
            },
            legend: { display: false },
            datalabels: {
              anchor: 'end',
              align: 'end',
              formatter: (value) => value.toLocaleString('es-MX'),
              color: '#333',
              font: { weight: 'bold', size: 11 }
            }
          },
          scales: {
            x: { ticks: { precision: 0 } },
            y: {
              ticks: { font: { size: 10 } },
              categoryPercentage: 0.7,
              barPercentage: 0.8
            }
          }
        },
        plugins: [ChartDataLabels]
      });
    }

    // ========== ACTUALIZAR CONTADOR DE SOLICITUDES ==========
    try {
      const totalSolicitudes = idsFiltradosIgnoreCol.length;
      
      // Contar solicitudes en vialidades primarias
      let enVialidadesPrimarias = 0;
      
      if (vialidadesLayer) {
        // Obtener el GeoJSON de vialidades
        const vialidadesGeoJSON = vialidadesLayer.toGeoJSON();
        
        idsFiltradosIgnoreCol.forEach(id => {
          const s = solicitudPorId[id];
          if (!s) return;
          
          const lon = Number(s["Coordenada X"]);
          const lat = Number(s["Coordenada Y"]);
          
          if (!isNaN(lon) && !isNaN(lat)) {
            const punto = turf.point([lon, lat]);
            
            // Verificar si el punto está dentro de algún polígono de vialidades
            let dentroDeVialidad = false;
            for (let feature of vialidadesGeoJSON.features) {
              if (turf.booleanPointInPolygon(punto, feature)) {
                dentroDeVialidad = true;
                break;
              }
            }
            
            if (dentroDeVialidad) {
              enVialidadesPrimarias++;
            }
          }
        });
      }
      
      const enVialidadesLocales = totalSolicitudes - enVialidadesPrimarias;
      
      // Actualizar display
      const totalSpan = document.getElementById('totalSolicitudes');
      if (totalSpan) {
        totalSpan.innerHTML = `<span style="font-size:1.1em">${totalSolicitudes.toLocaleString('es-MX')}</span> (Vialidades Primarias: <span style="font-size:1.1em">${enVialidadesPrimarias.toLocaleString('es-MX')}</span>, Vialidades Locales: <span style="font-size:1.1em">${enVialidadesLocales.toLocaleString('es-MX')}</span>)`;
      }
    } catch (e) {
      console.log('Error actualizando contador:', e);
    }

    // ========== TABLA RESUMEN ==========
    // La tabla resumen SOLO se afecta por el filtro de Tipo (ignora Estado y Mes)
    try {
      if (isMobile) {
        // Aplazar tabla en móviles para que gráficas se rendericen primero
        setTimeout(() => generarTablaResumen(filtroTipo), 100);
      } else {
        generarTablaResumen(filtroTipo);
      }
    } catch (e) {
      console.log('Error actualizando tablaResumen:', e);
    }

    // ========== CHOROPLETH ==========
    if (coloniasLayer) {
      // Primero calcular total de solicitudes por colonia respetando filtros
      const totalsArr = [];
      const totalsByCol = {};

      // Obtener totals a partir de countsByColNorm (ya filtrados)
      coloniasLayer.eachLayer(layer => {
        const nombre = layer.feature.properties.NOMBRE;
        const nombreNorm = layer.feature.properties._normName || normalizeKey(nombre);
        const info = countsByColNorm[nombreNorm];
        const total = info ? info.total : 0;
        totalsByCol[nombre] = total;
        if (total > 0) totalsArr.push(total);
      });

      const numClasses = 5;
      if (totalsArr.length === 0) {
        // No hay datos: pintar todo gris claro
        coloniasLayer.eachLayer(layer => {
          try {
            layer.setStyle({ fillColor: "#eee", fillOpacity: 0.2, color: "#555", weight: 1 });
            const nombre = layer.feature.properties.NOMBRE;
            const total = totalsByCol[nombre] || 0;
            layer.bindPopup(`<b>${nombre}</b><br>Solicitudes: ${total}`);
          } catch (e) {
            console.log("Error en choropleth (sin datos):", e);
          }
        });
      } else {
        // Calcular quiebres Jenks (manejar si hay menos valores que clases)
        const clases = Math.min(numClasses, totalsArr.length);
        let breaks = [];
        try {
          breaks = getJenksBreaks(totalsArr, clases);
        } catch (e) {
          console.log('Error calculando Jenks:', e);
          // fallback: usar percentiles simples
          totalsArr.sort((a,b)=>a-b);
          breaks = [];
          for (let i=1;i<=clases;i++) {
            const idx = Math.floor((totalsArr.length * i) / clases) - 1;
            breaks.push(totalsArr[Math.max(0, Math.min(totalsArr.length-1, idx))]);
          }
        }

        // Asegurar que los quiebres estén ordenados y sean únicos
        breaks = Array.from(new Set(breaks)).sort((a,b)=>a-b);

        coloniasLayer.eachLayer(layer => {
          const nombre = layer.feature.properties.NOMBRE;
          const total = totalsByCol[nombre] || 0;

          let fill = "#eee";
          let opacity = 0.2;

          if (total > 0) {
            // Determinar clase: 0..(breaks.length-1)
            let cls = 0;
            for (let i = 0; i < breaks.length; i++) {
              if (total <= breaks[i]) { cls = i; break; }
              cls = i;
            }
            fill = classColor(cls);
            // mapear opacidad según clase (más solicitudes -> mayor opacidad)
            opacity = 0.35 + (cls / Math.max(1, breaks.length - 1)) * 0.55;
          }

          try {
            layer.setStyle({ fillColor: fill, fillOpacity: opacity, color: "#555", weight: 1 });
            layer.bindPopup(`<b>${nombre}</b><br>Solicitudes: ${total}`);
          } catch (e) {
            console.log("Error en choropleth (pintado):", e);
          }
        });
        // Actualizar leyenda con los quiebres calculados
        try { updateLegend(breaks); } catch (e) { console.log('Error actualizando leyenda:', e); }
      }
    }
    else {
      // Si no hay coloniasLayer o sin datos, limpiar la leyenda
      try { updateLegend(null); } catch(e){}
    }

    // Ocultar overlay al terminar render (delay mayor en móviles)
    try { setTimeout(hideLoading, isMobile ? 800 : 500); } catch(e){}
  }

  // ========== GENERAR TABLA RESUMEN ==========
  // Tabla resumen (con Pendientes/En Atención + Indicador dinámico + Totales en negritas)
  // Solo se afecta por filtro de Tipo, ignora Estado y Mes
  function generarTablaResumen(filtroTipo){
    // Filtrar SOLO por tipo (ignorar estado y mes para la tabla)
    let datos = solicitudes;
    if (filtroTipo && filtroTipo !== 'Todos') {
      datos = solicitudes.filter(s => s["Tipo de reporte"] === filtroTipo);
    }
    
    let resumen = {};
    datos.forEach(s => {
      if(!s["Fecha reporte"] || !s["Estado Reporte"]) return;
      let fecha = new Date(s["Fecha reporte"]);
      if(isNaN(fecha)) return;

      // clave por año-mes
      let mesClave = fecha.getFullYear()+"-"+(fecha.getMonth()+1).toString().padStart(2,"0");
      if(!resumen[mesClave]) {
        resumen[mesClave] = {
          Atendido:0,
          Pendiente:0,
          "En atención":0,
          "No compete":0,
          PendientesMes:0,
          PendientesAcumulado:0,
          IndicadorDias:0
        };
      }

      let estado = s["Estado Reporte"].trim();
      if(estado==="Pendiente"){
        resumen[mesClave].Pendiente++;
      } else if(estado==="En atención"){
        resumen[mesClave]["En atención"]++;
      } else if(estado==="Atendido"){
        resumen[mesClave].Atendido++;
      } else if(estado==="No compete"){
        resumen[mesClave]["No compete"]++;
      }
    });

    // Orden cronológico de meses (YYYY-MM)
    let mesesOrdenados = Object.keys(resumen).sort();

    // Calcular Pendientes/En Atención, acumulado y el indicador dinámico
    let acumulado = 0;
    let totalMeses = mesesOrdenados.length;
    mesesOrdenados.forEach((m, idx) => {
      const fila = resumen[m];
      fila.PendientesMes = fila.Pendiente + fila["En atención"];
      acumulado += fila.PendientesMes;
      fila.PendientesAcumulado = acumulado;

      // Factor dinámico: último mes = 1, hacia atrás +30 cada vez
      let distanciaDesdeFinal = (totalMeses - 1) - idx;
      let factor = distanciaDesdeFinal * 30;
      if (distanciaDesdeFinal === 0) factor = 1; // último mes = 1
      fila.IndicadorDias = fila.PendientesMes * factor;
    });

    // Renderizar tabla
    let tabla = `<table class="table table-striped">
      <thead><tr>
        <th>Mes</th><th>Atendido</th><th>Pendiente</th><th>En atención</th>
        <th>No compete</th><th>Total por Mes</th><th>Pendientes/En Atención</th>
        <th>Pendientes/En Atención (Acumulado)</th>
        <th>Indicador de días por solicitudes</th>
      </tr></thead><tbody>`;

    // Variables para totales
    let totalAtendido = 0, totalPendiente = 0, totalEnAtencion = 0, totalNoCompete = 0;
    let totalPendMes = 0, totalPendAcum = 0, totalIndicador = 0, totalPorMesSum = 0;

    mesesOrdenados.forEach(m => {
      const r = resumen[m];
      const [anio, mesNum] = m.split("-");
      let nombreMes = new Date(anio, parseInt(mesNum)-1).toLocaleString('es-ES',{month:'long'});
      nombreMes = nombreMes.charAt(0).toUpperCase() + nombreMes.slice(1);

      const totalMes = r.Atendido + r.Pendiente + r["En atención"] + r["No compete"];
      
      tabla += `<tr>
        <td>${nombreMes} ${anio}</td>
        <td>${r.Atendido.toLocaleString('es-MX')}</td>
        <td>${r.Pendiente.toLocaleString('es-MX')}</td>
        <td>${r["En atención"].toLocaleString('es-MX')}</td>
        <td>${r["No compete"].toLocaleString('es-MX')}</td>
        <td>${totalMes.toLocaleString('es-MX')}</td>
        <td>${r.PendientesMes.toLocaleString('es-MX')}</td>
        <td>${r.PendientesAcumulado.toLocaleString('es-MX')}</td>
        <td>${r.IndicadorDias.toLocaleString('es-MX')}</td>
      </tr>`;

      // Acumular totales
      totalAtendido += r.Atendido;
      totalPendiente += r.Pendiente;
      totalEnAtencion += r["En atención"];
      totalNoCompete += r["No compete"];
      totalPorMesSum += totalMes;
      totalPendMes += r.PendientesMes;
      totalPendAcum = r.PendientesAcumulado; // el acumulado final es el último valor
      totalIndicador += r.IndicadorDias;
    });

    // Fila de totales en negritas
    tabla += `<tr style="font-weight:bold;">
      <td>Total</td>
      <td>${totalAtendido.toLocaleString('es-MX')}</td>
      <td>${totalPendiente.toLocaleString('es-MX')}</td>
      <td>${totalEnAtencion.toLocaleString('es-MX')}</td>
      <td>${totalNoCompete.toLocaleString('es-MX')}</td>
      <td>${totalPorMesSum.toLocaleString('es-MX')}</td>
      <td>${totalPendMes.toLocaleString('es-MX')}</td>
      <td>${totalPendAcum.toLocaleString('es-MX')}</td>
      <td>${totalIndicador.toLocaleString('es-MX')}</td>
    </tr>`;

    tabla += `</tbody></table>`;
    document.getElementById("tablaResumen").innerHTML = tabla;
  }

  // ========== INICIALIZADOR FILTROS ==========
  function inicializarFiltros() {
    let tiposUnicos = [...new Set(solicitudes.map(s => s["Tipo de reporte"]).filter(Boolean))];
    let selectTipo = document.getElementById("filtroTipo");
    tiposUnicos.forEach(t => {
      let opt = document.createElement("option");
      opt.value = t;
      opt.textContent = t;
      selectTipo.appendChild(opt);
    });

    let estadosUnicos = [...new Set(solicitudes.map(s => s["Estado Reporte"]).filter(Boolean))];
    let selectEstado = document.getElementById("filtroEstado");
    estadosUnicos.forEach(e => {
      let opt = document.createElement("option");
      opt.value = e;
      opt.textContent = e;
      selectEstado.appendChild(opt);
    });

    let mesesUnicos = [...new Set(solicitudes.map(s => {
      if (!s["Fecha reporte"]) return null;
      let fecha = new Date(s["Fecha reporte"]);
      if (isNaN(fecha)) return null;
      return fecha.toLocaleString('es-ES', { month: 'long' });
    }).filter(Boolean))];

    let selectMes = document.getElementById("filtroMes");
    mesesUnicos.forEach(m => {
      let opt = document.createElement("option");
      opt.value = m;
      opt.textContent = m.charAt(0).toUpperCase() + m.slice(1);
      selectMes.appendChild(opt);
    });
  }

  // ========== CARGAR DATOS ==========
  console.log("Iniciando carga de datos...");
  // Mostrar overlay de carga al iniciar
  try { if (typeof showLoading === 'function') showLoading(); } catch(e){}
  
  let coloniasLoaded = false;
  let solicitudesLoaded = false;

  function iniciarSiTodoEstaListo() {
    if (coloniasLoaded && solicitudesLoaded) {
      console.log("✅ TODOS LOS DATOS CARGADOS");
      precalcularIndices();
      inicializarFiltros();
      renderizar("Todos", "Todos", "Todos");
      console.log("✅ Inicialización completa");
      try { if (typeof hideLoading === 'function') hideLoading(); } catch(e){}
    }
  }

  // Cargar colonias
  fetch("archivos/vectores/colonias_wgs84_geojson_renombrado.geojson")
    .then(res => res.json())
    .then(data => {
      if (coloniasLayer) return; // Evitar duplicación
      // Desactivado: mantemos geometría original para evitar deformaciones en móvil
      
      coloniasLayer = L.geoJson(data, {
        renderer: L.canvas(),
        smoothFactor: 0,
        style: function(feature) {
          return {
            color: "#555",
            weight: 1,
            fill: true,
            fillColor: "#eee",
            fillOpacity: 0.6
          };
        },
        onEachFeature: function(feature, layer) {
          const nombreColonia = feature.properties.NOMBRE;
          // Guardar versión normalizada en la propiedad para comparaciones rápidas
          try { feature.properties._normName = normalizeKey(nombreColonia); } catch(e) { feature.properties._normName = null; }
          layer.bindPopup(`<b>${nombreColonia}</b><br>Solicitudes: 0`);

          layer.on('click', function(e) {
            if (L && L.DomEvent) L.DomEvent.stopPropagation(e);

            if (selectedOutline) {
              map.removeLayer(selectedOutline);
              selectedOutline = null;
            }

            selectedOutline = L.geoJSON(layer.toGeoJSON(), {
              style: { color: "red", weight: 3, fill: false }
            }).addTo(map);

            if (selectedOutline.bringToFront) selectedOutline.bringToFront();

            layer.openPopup();
            coloniaSeleccionada = layer;
            // Renderizar respetando los filtros activos (no forzar 'Todos')
            try {
              const tipo = document.getElementById('filtroTipo')?.value || 'Todos';
              const estado = document.getElementById('filtroEstado')?.value || 'Todos';
              const mes = document.getElementById('filtroMes')?.value || 'Todos';
              renderizar(tipo, estado, mes);
            } catch (e) {
              renderizar('Todos','Todos','Todos');
            }
          });

          layer.on('popupclose', function() {
            if (selectedOutline) {
              map.removeLayer(selectedOutline);
              selectedOutline = null;
            }
            if (coloniaSeleccionada === layer) {
              coloniaSeleccionada = null;
              // Restaurar la visualización previa llamando a renderizar con filtros actuales
              try {
                const tipo = document.getElementById('filtroTipo')?.value || 'Todos';
                const estado = document.getElementById('filtroEstado')?.value || 'Todos';
                const mes = document.getElementById('filtroMes')?.value || 'Todos';
                renderizar(tipo, estado, mes);
              } catch (e) {
                renderizar('Todos','Todos','Todos');
              }
            }
          });
        }
      }).addTo(map);

      coloniasLayer.eachLayer(layer => {
        let nombre = layer.feature.properties.NOMBRE;
        let norm = layer.feature.properties._normName || normalizeKey(nombre);
        if (norm) normToColoniaName[norm] = nombre;
        if(nombre) {
          // Guardar para autocompletado
          coloniasList.push(nombre);
          let opt = document.createElement("option");
          opt.value = nombre;
          document.getElementById("sugerenciasColonias").appendChild(opt);
        }
      });

      // Dejar única y ordenada la lista de colonias
      try {
        coloniasList = Array.from(new Set(coloniasList)).sort((a,b)=>a.localeCompare(b,'es',{sensitivity:'base'}));
      } catch(e) {}

      coloniasLoaded = true;
      console.log("✅ Colonias cargadas");
      // Inicializar el autocompletado una vez que tengamos colonias
      try { initializeAutocompleteFallback(); } catch(e) { console.log('Autocomplete init error', e); }
      iniciarSiTodoEstaListo();
    })
    .catch(err => console.error("Error al cargar colonias:", err));

  // Cargar vialidades
  console.log("Cargando vialidades...");
  fetch("./archivos/vectores/vialidades.geojson")
    .then(res => {
      console.log("Respuesta de vialidades recibida, status:", res.status);
      if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`);
      return res.json();
    })
    .then(data => {
      console.log("JSON parseado correctamente");
      if (vialidadesLayer) {
        console.log("Vialidades ya cargadas, saltando...");
        return;
      }
      
      console.log("Datos de vialidades parseados:", data.features ? data.features.length : 0, "features");
      console.log("✅ Las coordenadas ya están en WGS84, no se necesita transformación");
      
      // Crear capa de vialidades con polígonos rellenos
      vialidadesLayer = L.geoJson(data, {
          style: function(feature) {
            return {
              fillColor: "#2563EB",    // Azul rey relleno
              fillOpacity: 0.5,        // Opacidad del relleno
              color: "#1E40AF",        // Borde azul más oscuro
              weight: 1,               // Borde delgado
              opacity: 0.7
            };
          },
          onEachFeature: function(feature, layer) {
            // Si hay nombre de vialidad, mostrar en popup
            const nombre = feature.properties.NOMBRE || feature.properties.NOMENCLAT || feature.properties.NOMBREVIAL || 'Vialidad';
            const tipo = feature.properties.TIPO_VIA || '';
            layer.bindPopup(`<b>${nombre}</b>${tipo ? '<br>' + tipo : ''}`);
          }
      }).addTo(map);

      // Asegurar que las vialidades estén ENCIMA de todas las capas
      if (vialidadesLayer) {
        if (vialidadesLayer.bringToFront) {
          vialidadesLayer.bringToFront();
        }
        
        // Hacer zoom a las vialidades para verificar que se cargaron
        try {
          const bounds = vialidadesLayer.getBounds();
          console.log("Bounds de vialidades:", bounds);
          console.log("Vialidades visibles en el mapa:", map.hasLayer(vialidadesLayer));
          
          // Activar zoom temporal para verificar ubicación
          setTimeout(() => {
            map.fitBounds(bounds);
            console.log("Zoom aplicado a vialidades");
          }, 2000);
        } catch (e) {
          console.log("No se pudo obtener bounds:", e);
        }
      }

      console.log("✅ Vialidades cargadas y añadidas al mapa");
      console.log("Capas en el mapa:", map._layers);
    })
    .catch(err => {
      console.error("❌ Error al cargar vialidades:", err);
      alert("Error al cargar vialidades: " + err.message);
    });

  // Cargar solicitudes
  fetch("archivos/solicitudes/Diciembre2025.geojson")
    .then(res => res.json())
    .then(data => {
      if (solicitudesGeoJSON) return; // Evitar duplicación
      
      solicitudesGeoJSON = data;

      // En móviles: procesar en chunks para no bloquear UI
      const processChunk = (features, startIdx = 0) => {
        const chunkSize = isMobile ? 1000 : 5000; // Procesar en lotes
        const endIdx = Math.min(startIdx + chunkSize, features.length);
        
        for (let i = startIdx; i < endIdx; i++) {
          const f = features[i];
          if (!f.geometry || f.geometry.type !== "Point" || !Array.isArray(f.geometry.coordinates)) continue;
          
          const rawCol = f.properties["name"] || f.properties["NOMBRE"] || f.properties["colonia"] || null;
          solicitudes.push({
            "Número folio": f.properties["Número folio"],
            "Tipo de reporte": f.properties["Tipo de reporte"],
            "Estado Reporte": f.properties["Estado Reporte"],
            "Fecha reporte": f.properties["Fecha reporte"],
            "Nombre Ciudadano": f.properties["Nombre Ciudadano"],
            "Teléfono": f.properties["Teléfono"],
            "Punto de referencia": f.properties["Punto de referencia"],
            "Coordenada X": f.geometry.coordinates[0],
            "Coordenada Y": f.geometry.coordinates[1],
            "Colonia": rawCol,
            "ColoniaNorm": normalizeKey(rawCol)
          });
        }
        
        // Si hay más datos, procesar siguiente chunk de forma asíncrona
        if (endIdx < features.length) {
          setTimeout(() => processChunk(features, endIdx), 10);
        } else {
          console.log("✅ Solicitudes cargadas:", solicitudes.length);
          solicitudesLoaded = true;
          iniciarSiTodoEstaListo();
        }
      };

      // Iniciar procesamiento
      processChunk(data.features);
    })
    .catch(err => console.error("Error al cargar solicitudes:", err));

  // ========== EVENT LISTENERS ==========
  let btnAplicarFiltros = document.getElementById("btnAplicarFiltros");
  let btnBuscarGeneral = document.getElementById("btnBuscarGeneral");
  let btnResetBuscar = document.getElementById("btnResetBuscar");
  
    // ✅ NUEVA OPTIMIZACIÓN: Debounce para renderizado suave
    const renderizarDebounced = debounce(renderizar, 150);
  
  // Agregar listeners solo una vez
  if (btnAplicarFiltros && !btnAplicarFiltros.hasListener) {
    btnAplicarFiltros.addEventListener("click", () => {
      const tipo = document.getElementById("filtroTipo").value;
      const estado = document.getElementById("filtroEstado").value;
      const mes = document.getElementById("filtroMes").value;
      // Usar debounce para evitar clics múltiples rápidos
      renderizarDebounced(tipo, estado, mes);
    });
    btnAplicarFiltros.hasListener = true;
  }

  if (btnBuscarGeneral && !btnBuscarGeneral.hasListener) {
    btnBuscarGeneral.addEventListener("click", () => {
      let valor = document.getElementById("buscadorGeneral").value.trim();
      if (!valor) return;

      let solicitud = solicitudes.find(s => s["Número folio"] == valor);
      if (solicitud) {
        let lat = parseFloat(solicitud["Coordenada Y"]);
        let lon = parseFloat(solicitud["Coordenada X"]);
        if (!isNaN(lat) && !isNaN(lon)) {
          // Hacer zoom a nivel 17 (suficiente para ver puntos)
          map.setView([lat, lon], 17);
          
          // Crear y mostrar popup con la información del folio
          const popupContent = `
            <div style="max-width: 250px;">
              <b>Folio:</b> ${solicitud["Número folio"]}<br>
              <b>Ciudadano:</b> ${solicitud["Nombre Ciudadano"] || 'N/A'}<br>
              <b>Teléfono:</b> ${solicitud["Teléfono"] || 'N/A'}<br>
              <b>Tipo:</b> ${solicitud["Tipo de reporte"]}<br>
              <b>Estado:</b> ${solicitud["Estado Reporte"]}<br>
              <b>Punto de referencia:</b> ${solicitud["Punto de referencia"] || 'N/A'}<br>
              <b>Fecha:</b> ${solicitud["Fecha reporte"] || 'N/A'}
            </div>
          `;
          L.popup()
            .setLatLng([lat, lon])
            .setContent(popupContent)
            .openOn(map);
        }

        let tipo = solicitud["Tipo de reporte"];
        let estado = solicitud["Estado Reporte"];
        document.getElementById("filtroTipo").value = tipo || "Todos";
        document.getElementById("filtroEstado").value = estado || "Todos";
        renderizar(tipo || "Todos", estado || "Todos", "Todos");
        return;
      }
      // Si no es folio, intentar buscar por colonia (normalizando texto)
      const valorNorm = normalizeKey(valor);
      let foundColoniaLayer = null;
      try {
        if (coloniasLayer) {
          coloniasLayer.eachLayer(layer => {
            const name = layer.feature && (layer.feature.properties && (layer.feature.properties.NOMBRE || layer.feature.properties.name));
            const n = normalizeKey(name);
            if (n && valorNorm && n === valorNorm) {
              foundColoniaLayer = layer;
            }
          });
        }
      } catch (e) {
        console.log('Error buscando colonia:', e);
      }

      if (foundColoniaLayer) {
        // Hacer zoom a la colonia
        try {
          const bounds = foundColoniaLayer.getBounds();
          map.fitBounds(bounds);
          // Después de fitBounds, hacer zoom adicional si es necesario para ver puntos
          setTimeout(() => {
            if (map.getZoom() < 16) map.setZoom(16);
          }, 100);
        } catch (e) {
          console.log("Error en fitBounds:", e);
        }
        
        // Seleccionar colonia y dibujar contorno rojo
        coloniaSeleccionada = foundColoniaLayer;
        
        if (selectedOutline) {
          map.removeLayer(selectedOutline);
          selectedOutline = null;
        }
        
        selectedOutline = L.geoJSON(foundColoniaLayer.toGeoJSON(), {
          style: { color: "red", weight: 3, fill: false }
        }).addTo(map);
        
        if (selectedOutline.bringToFront) selectedOutline.bringToFront();

        // Renderizar con filtros actuales
        const tipo = document.getElementById('filtroTipo')?.value || 'Todos';
        const estado = document.getElementById('filtroEstado')?.value || 'Todos';
        const mes = document.getElementById('filtroMes')?.value || 'Todos';
        renderizar(tipo, estado, mes);
        return;
      }

      alert("No se encontró folio ni colonia con: " + valor);
    });
    btnBuscarGeneral.hasListener = true;
  }

  // ========== AUTOCOMPLETADO FALLBACK (MÓVIL Y ESCRITORIO) ==========
  function initializeAutocompleteFallback() {
    // Activar en todos los dispositivos para experiencia uniforme
    try {
      const input = document.getElementById('buscadorGeneral');
      if (!input) return;
      const group = input.closest('.input-group') || document.getElementById('sidebar');
      if (!group) return;

      // Crear contenedor si no existe
      if (!autocompleteContainer) {
        autocompleteContainer = document.createElement('div');
        autocompleteContainer.id = 'autocompleteList';
        autocompleteContainer.className = 'autocomplete-list';
        autocompleteContainer.style.display = 'none';
        group.appendChild(autocompleteContainer);
      }

      const renderSuggestions = (q) => {
        if (!q || q.trim().length < 1) { autocompleteContainer.style.display = 'none'; autocompleteContainer.innerHTML=''; return; }
        const qn = normalizeKey(q);
        const matches = [];
        for (let i = 0; i < coloniasList.length; i++) {
          const name = coloniasList[i];
          const nn = normalizeKey(name);
          if (nn && nn.indexOf(qn) !== -1) {
            matches.push({ name, pos: nn.indexOf(qn) });
          }
          if (matches.length >= 50) break; // límite razonable
        }
        matches.sort((a,b)=> a.pos - b.pos || a.name.localeCompare(b.name,'es',{sensitivity:'base'}));
        const top = matches.slice(0, 15);
        if (top.length === 0) { autocompleteContainer.style.display = 'none'; autocompleteContainer.innerHTML=''; return; }

        let html = '';
        top.forEach(m => {
          html += `<div class="autocomplete-item" data-value="${m.name.replace(/"/g,'&quot;')}">${m.name}</div>`;
        });
        autocompleteContainer.innerHTML = html;
        autocompleteContainer.style.display = 'block';

        // Click handler por item
        Array.from(autocompleteContainer.children).forEach(el => {
          el.addEventListener('click', () => {
            const val = el.getAttribute('data-value');
            input.value = val || '';
            autocompleteContainer.style.display = 'none';
            // No disparamos búsqueda automática; usuario decide
          }, { once: true });
        });
      };

      // Listeners del input
      input.addEventListener('input', () => renderSuggestions(input.value));
      input.addEventListener('focus', () => {
        if (input.value && input.value.length > 0) renderSuggestions(input.value);
      });
      input.addEventListener('blur', () => {
        // delay más largo para permitir click/touch en la lista (especialmente en móvil)
        setTimeout(() => { if (autocompleteContainer) autocompleteContainer.style.display = 'none'; }, 300);
      });

      // Enter: si hay sugerencias visibles, tomar la primera
      input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && autocompleteContainer && autocompleteContainer.style.display !== 'none') {
          const first = autocompleteContainer.querySelector('.autocomplete-item');
          if (first) {
            e.preventDefault();
            input.value = first.getAttribute('data-value');
            autocompleteContainer.style.display = 'none';
          }
        }
      });
    } catch (e) {
      console.log('Autocomplete fallback error:', e);
    }
  }

  if (btnResetBuscar && !btnResetBuscar.hasListener) {
    btnResetBuscar.addEventListener("click", () => {
      // Mostrar loading overlay y deshabilitar botón de inmediato (síncrono)
      const loadingDiv = document.getElementById('loadingOverlay');
      if (loadingDiv) loadingDiv.style.display = 'flex';
      btnResetBuscar.disabled = true;
      btnResetBuscar.style.opacity = '0.5';
      
      document.getElementById("buscadorGeneral").value = "";
      document.getElementById("filtroTipo").value = "Todos";
      document.getElementById("filtroEstado").value = "Todos";
      document.getElementById("filtroMes").value = "Todos";
      coloniaSeleccionada = null;
      if (selectedOutline) {
        map.removeLayer(selectedOutline);
        selectedOutline = null;
      }
      renderizar("Todos", "Todos", "Todos");
      map.setView([19.35, -99.2], 13);
      // Re-habilitar botón después de que termine la carga
      setTimeout(() => {
        btnResetBuscar.disabled = false;
        btnResetBuscar.style.opacity = '1';
      }, 600);
    });
    btnResetBuscar.hasListener = true;
  }

  // ========== TABLA POR TIPO DE SOLICITUD (INVERSA) ==========
  function generarTablaTipos() {
    // Si ya está generada, solo reactivar listeners
    if (tablasGeneradas.tipos) {
      adjuntarListenersTipos();
      habilitarSeleccionCeldas();
      return;
    }
    
    // Agrupar solicitudes por tipo - OPTIMIZADO
    const tipos = {};
    const len = solicitudes.length;
    
    for (let i = 0; i < len; i++) {
      const s = solicitudes[i];
      const tipo = s["Tipo de reporte"] || "Sin tipo";
      const tel = s["Teléfono"] || "Sin teléfono";
      const nombre = s["Nombre Ciudadano"] || "Sin nombre";
      const estado = s["Estado Reporte"] || "Sin estado";
      
      if (!tipos[tipo]) {
        tipos[tipo] = {
          tipo: tipo,
          total: 0,
          atendido: 0,
          pendiente: 0,
          enAtencion: 0,
          noCompete: 0,
          ciudadanos: {}
        };
      }
      
      const tipoObj = tipos[tipo];
      tipoObj.total++;
      
      // Contabilizar por estado - optimizado
      switch(estado) {
        case "Atendido": tipoObj.atendido++; break;
        case "Pendiente": tipoObj.pendiente++; break;
        case "En atención": tipoObj.enAtencion++; break;
        case "No compete": tipoObj.noCompete++; break;
      }
      
      // Agrupar por ciudadano dentro del tipo
      const ciudadanoKey = tel + '|' + nombre;
      if (!tipoObj.ciudadanos[ciudadanoKey]) {
        tipoObj.ciudadanos[ciudadanoKey] = {
          telefono: tel,
          nombre: nombre,
          total: 0,
          atendido: 0,
          pendiente: 0,
          enAtencion: 0,
          noCompete: 0
        };
      }
      
      const ciudadanoObj = tipoObj.ciudadanos[ciudadanoKey];
      ciudadanoObj.total++;
      switch(estado) {
        case "Atendido": ciudadanoObj.atendido++; break;
        case "Pendiente": ciudadanoObj.pendiente++; break;
        case "En atención": ciudadanoObj.enAtencion++; break;
        case "No compete": ciudadanoObj.noCompete++; break;
      }
    }
    
    // Convertir a array y ordenar por total descendente
    const tiposArray = Object.values(tipos).sort((a, b) => b.total - a.total);
    
    // Generar HTML usando array - MÁS RÁPIDO
    const htmlParts = [];
    htmlParts.push('<table class="tabla-ciudadanos"><thead><tr>');
    htmlParts.push('<th style="width:40px;"></th>');
    htmlParts.push('<th>Tipo de Solicitud</th>');
    htmlParts.push('<th>Atendido</th>');
    htmlParts.push('<th>Pendiente</th>');
    htmlParts.push('<th>En atención</th>');
    htmlParts.push('<th>No compete</th>');
    htmlParts.push('<th>Total</th>');
    htmlParts.push('</tr></thead><tbody>');
    
    tiposArray.forEach((t, idx) => {
      const detailId = 'detail-tipo-' + idx;
      
      // Fila principal
      htmlParts.push(`<tr class="toggle-row" data-target="${detailId}">`);
      htmlParts.push(`<td style="text-align:center;"><span class="toggle-icon">▶</span></td>`);
      htmlParts.push(`<td><strong>${t.tipo}</strong></td>`);
      htmlParts.push(`<td style="text-align:center;">${t.atendido}</td>`);
      htmlParts.push(`<td style="text-align:center;">${t.pendiente}</td>`);
      htmlParts.push(`<td style="text-align:center;">${t.enAtencion}</td>`);
      htmlParts.push(`<td style="text-align:center;">${t.noCompete}</td>`);
      htmlParts.push(`<td style="text-align:center; font-weight:bold;">${t.total}</td>`);
      htmlParts.push('</tr>');
      
      // Fila de detalle con ciudadanos
      htmlParts.push(`<tr class="detail-row" id="${detailId}">`);
      htmlParts.push('<td colspan="7"><div class="detail-content">');
      htmlParts.push('<strong>Ciudadanos que reportaron este tipo:</strong>');
      htmlParts.push('<table class="detail-table"><thead><tr>');
      htmlParts.push('<th style="color:#000;">Número Teléfono</th>');
      htmlParts.push('<th style="color:#000;">Nombre</th>');
      htmlParts.push('<th style="text-align:center; color:#000;">Atendido</th>');
      htmlParts.push('<th style="text-align:center; color:#000;">Pendiente</th>');
      htmlParts.push('<th style="text-align:center; color:#000;">En atención</th>');
      htmlParts.push('<th style="color:#000;">No compete</th>');
      htmlParts.push('<th style="text-align:center; color:#000;">Total</th>');
      htmlParts.push('</tr></thead><tbody>');
      
      // Ordenar ciudadanos por total descendente
      const ciudadanosOrdenados = Object.values(t.ciudadanos).sort((a, b) => b.total - a.total);
      ciudadanosOrdenados.forEach(c => {
        htmlParts.push(`<tr><td>${c.telefono}</td><td>${c.nombre}</td>`);
        htmlParts.push(`<td style="text-align:center;">${c.atendido}</td>`);
        htmlParts.push(`<td style="text-align:center;">${c.pendiente}</td>`);
        htmlParts.push(`<td style="text-align:center;">${c.enAtencion}</td>`);
        htmlParts.push(`<td style="text-align:center;">${c.noCompete}</td>`);
        htmlParts.push(`<td style="text-align:center; font-weight:bold;">${c.total}</td></tr>`);
      });
      
      htmlParts.push('</tbody></table></div></td></tr>');
    });
    
    htmlParts.push('</tbody></table>');
    
    // Insertar HTML de forma asíncrona para no bloquear el navegador
    requestAnimationFrame(() => {
      document.getElementById('contenidoTablaTipos').innerHTML = htmlParts.join('');
      tablasGeneradas.tipos = true; // Marcar como generada
      requestAnimationFrame(() => {
        adjuntarListenersTipos();
        habilitarSeleccionCeldas();
      });
    });
  }
  
  function adjuntarListenersTipos() {
    // Remover listeners duplicados clonando elementos
    document.querySelectorAll('#contenidoTablaTipos .toggle-icon').forEach(icon => {
      const newIcon = icon.cloneNode(true);
      icon.parentNode.replaceChild(newIcon, icon);
      
      newIcon.style.cursor = 'pointer';
      newIcon.addEventListener('click', function(e) {
        e.stopPropagation();
        const row = this.closest('.toggle-row');
        const targetId = row.getAttribute('data-target');
        const detailRow = document.getElementById(targetId);
        
        if (detailRow.classList.contains('show')) {
          detailRow.classList.remove('show');
          this.textContent = '▶';
        } else {
          detailRow.classList.add('show');
          this.textContent = '▼';
        }
      });
    });
    
    // Habilitar selección de celdas
    habilitarSeleccionCeldas();
  }

  // ========== TABLA CIUDADANOS ==========
  function generarTablaCiudadanos() {
    // Si ya está generada, solo reactivar listeners
    if (tablasGeneradas.ciudadanos) {
      adjuntarListenersCiudadanos();
      habilitarSeleccionCeldas();
      return;
    }
    
    // Agrupar solicitudes por teléfono - OPTIMIZADO
    const ciudadanos = {};
    const len = solicitudes.length;
    
    for (let i = 0; i < len; i++) {
      const s = solicitudes[i];
      const tel = s["Teléfono"] || "Sin teléfono";
      const nombre = s["Nombre Ciudadano"] || "Sin nombre";
      const tipo = s["Tipo de reporte"] || "Sin tipo";
      const estado = s["Estado Reporte"] || "Sin estado";
      
      if (!ciudadanos[tel]) {
        ciudadanos[tel] = {
          telefono: tel,
          nombre: nombre,
          total: 0,
          atendido: 0,
          pendiente: 0,
          enAtencion: 0,
          noCompete: 0,
          tipos: {}
        };
      }
      
      const ciudadanoObj = ciudadanos[tel];
      ciudadanoObj.total++;
      
      // Contabilizar por estado - optimizado con switch
      switch(estado) {
        case "Atendido": ciudadanoObj.atendido++; break;
        case "Pendiente": ciudadanoObj.pendiente++; break;
        case "En atención": ciudadanoObj.enAtencion++; break;
        case "No compete": ciudadanoObj.noCompete++; break;
      }
      
      // Contabilizar por tipo y estado
      if (!ciudadanoObj.tipos[tipo]) {
        ciudadanoObj.tipos[tipo] = {
          total: 0,
          atendido: 0,
          pendiente: 0,
          enAtencion: 0,
          noCompete: 0
        };
      }
      const tipoObj = ciudadanoObj.tipos[tipo];
      tipoObj.total++;
      switch(estado) {
        case "Atendido": tipoObj.atendido++; break;
        case "Pendiente": tipoObj.pendiente++; break;
        case "En atención": tipoObj.enAtencion++; break;
        case "No compete": tipoObj.noCompete++; break;
      }
    }
    
    // Convertir a array y ordenar por total descendente
    const ciudadanosArray = Object.values(ciudadanos).sort((a, b) => b.total - a.total);
    
    // Generar HTML usando array - MÁS RÁPIDO
    const htmlParts = [];
    htmlParts.push('<table class="tabla-ciudadanos"><thead><tr>');
    htmlParts.push('<th style="width:40px;"></th>');
    htmlParts.push('<th>Número Teléfono</th>');
    htmlParts.push('<th>Nombre</th>');
    htmlParts.push('<th>Atendido</th>');
    htmlParts.push('<th>Pendiente</th>');
    htmlParts.push('<th>En atención</th>');
    htmlParts.push('<th>No compete</th>');
    htmlParts.push('<th>Total</th>');
    htmlParts.push('</tr></thead><tbody>');
    
    ciudadanosArray.forEach((c, idx) => {
      const detailId = 'detail-' + idx;
      
      // Fila principal
      htmlParts.push(`<tr class="toggle-row" data-target="${detailId}">`);
      htmlParts.push(`<td style="text-align:center;"><span class="toggle-icon">▶</span></td>`);
      htmlParts.push(`<td>${c.telefono}</td>`);
      htmlParts.push(`<td>${c.nombre}</td>`);
      htmlParts.push(`<td style="text-align:center;">${c.atendido}</td>`);
      htmlParts.push(`<td style="text-align:center;">${c.pendiente}</td>`);
      htmlParts.push(`<td style="text-align:center;">${c.enAtencion}</td>`);
      htmlParts.push(`<td style="text-align:center;">${c.noCompete}</td>`);
      htmlParts.push(`<td style="text-align:center; font-weight:bold;">${c.total}</td>`);
      htmlParts.push('</tr>');
      
      // Fila de detalle
      htmlParts.push(`<tr class="detail-row" id="${detailId}">`);
      htmlParts.push('<td colspan="8"><div class="detail-content">');
      htmlParts.push('<strong>Detalle por tipo de solicitud:</strong>');
      htmlParts.push('<table class="detail-table"><thead><tr>');
      htmlParts.push('<th style="color:#000;">Tipo de Solicitud</th>');
      htmlParts.push('<th style="text-align:center; color:#000;">Atendido</th>');
      htmlParts.push('<th style="text-align:center; color:#000;">Pendiente</th>');
      htmlParts.push('<th style="text-align:center; color:#000;">En atención</th>');
      htmlParts.push('<th style="text-align:center; color:#000;">No compete</th>');
      htmlParts.push('<th style="text-align:center; color:#000;">Total</th>');
      htmlParts.push('</tr></thead><tbody>');
      
      // Ordenar tipos por cantidad descendente
      const tiposOrdenados = Object.entries(c.tipos).sort((a, b) => b[1].total - a[1].total);
      tiposOrdenados.forEach(([tipo, info]) => {
        htmlParts.push(`<tr><td>${tipo}</td>`);
        htmlParts.push(`<td style="text-align:center;">${info.atendido}</td>`);
        htmlParts.push(`<td style="text-align:center;">${info.pendiente}</td>`);
        htmlParts.push(`<td style="text-align:center;">${info.enAtencion}</td>`);
        htmlParts.push(`<td style="text-align:center;">${info.noCompete}</td>`);
        htmlParts.push(`<td style="text-align:center; font-weight:bold;">${info.total}</td></tr>`);
      });
      
      htmlParts.push('</tbody></table></div></td></tr>');
    });
    
    htmlParts.push('</tbody></table>');
    
    // Insertar HTML de forma asíncrona para no bloquear el navegador
    requestAnimationFrame(() => {
      document.getElementById('contenidoTablaCiudadanos').innerHTML = htmlParts.join('');
      tablasGeneradas.ciudadanos = true; // Marcar como generada
      requestAnimationFrame(() => {
        adjuntarListenersCiudadanos();
        habilitarSeleccionCeldas();
      });
    });
  }
  
  function adjuntarListenersCiudadanos() {
    // Remover listeners duplicados clonando elementos
    document.querySelectorAll('#contenidoTablaCiudadanos .toggle-icon').forEach(icon => {
      const newIcon = icon.cloneNode(true);
      icon.parentNode.replaceChild(newIcon, icon);
      
      newIcon.style.cursor = 'pointer';
      newIcon.addEventListener('click', function(e) {
        e.stopPropagation();
        const row = this.closest('.toggle-row');
        const targetId = row.getAttribute('data-target');
        const detailRow = document.getElementById(targetId);
        
        if (detailRow.classList.contains('show')) {
          detailRow.classList.remove('show');
          this.textContent = '▶';
        } else {
          detailRow.classList.add('show');
          this.textContent = '▼';
        }
      });
    });
    
    // Habilitar selección de celdas estilo Excel
    habilitarSeleccionCeldas();
  }
  
  // ========== SELECCIÓN DE CELDAS ESTILO EXCEL ==========
  let isSelecting = false;
  let selectedCells = new Set();
  
  function habilitarSeleccionCeldas() {
    const statsBar = document.getElementById('statsBar');
    const tables = document.querySelectorAll('.tabla-ciudadanos, .detail-table');
    
    tables.forEach(table => {
      // Seleccionar celdas con números (excluyendo primera columna del icono y columnas de texto)
      const cells = table.querySelectorAll('td');
      
      cells.forEach(cell => {
        // Solo habilitar en celdas con números
        const text = cell.textContent.trim();
        const parentRow = cell.closest('tr');
        const isToggleRow = parentRow && parentRow.classList.contains('toggle-row');
        const cellIndex = Array.from(cell.parentElement.children).indexOf(cell);
        
        // Excluir primera columna (icono) y columnas de teléfono/nombre (índices 1 y 2 en tabla principal)
        if (isToggleRow && cellIndex <= 2) return;
        if (cellIndex === 0 && cell.querySelector('.toggle-icon')) return;
        
        // Solo procesar si contiene número
        if (!/^\d+$/.test(text)) return;
        
        cell.style.userSelect = 'none';
        cell.style.cursor = 'cell';
        
        cell.addEventListener('mousedown', function(e) {
          e.preventDefault();
          if (e.shiftKey) {
            // Shift+click: agregar a selección
            if (this.classList.contains('selected')) {
              this.classList.remove('selected');
              selectedCells.delete(this);
            } else {
              this.classList.add('selected');
              selectedCells.add(this);
            }
          } else {
            // Click simple: nueva selección
            selectedCells.forEach(c => c.classList.remove('selected'));
            selectedCells.clear();
            this.classList.add('selected');
            selectedCells.add(this);
            isSelecting = true;
          }
          calcularEstadisticas();
        });
        
        cell.addEventListener('mouseenter', function() {
          if (isSelecting && !this.querySelector('.toggle-icon')) {
            this.classList.add('selected');
            selectedCells.add(this);
            calcularEstadisticas();
          }
        });
      });
    });
    
    document.addEventListener('mouseup', () => {
      isSelecting = false;
    });
    
    // Cerrar barra al hacer clic fuera de las tablas
    document.addEventListener('click', (e) => {
      if (!e.target.closest('.tabla-ciudadanos') && 
          !e.target.closest('.detail-table') && 
          !e.target.closest('#statsBar')) {
        selectedCells.forEach(c => c.classList.remove('selected'));
        selectedCells.clear();
        if (statsBar) statsBar.style.display = 'none';
      }
    });
  }
  
  function calcularEstadisticas() {
    const statsBar = document.getElementById('statsBar');
    const statCount = document.getElementById('statCount');
    const statSum = document.getElementById('statSum');
    const statAvg = document.getElementById('statAvg');
    
    if (selectedCells.size === 0) {
      if (statsBar) statsBar.style.display = 'none';
      return;
    }
    
    const valores = [];
    selectedCells.forEach(cell => {
      const text = cell.textContent.trim();
      const num = parseFloat(text.replace(/,/g, ''));
      if (!isNaN(num)) valores.push(num);
    });
    
    if (valores.length === 0) {
      if (statsBar) statsBar.style.display = 'none';
      return;
    }
    
    const count = valores.length;
    const sum = valores.reduce((a, b) => a + b, 0);
    const avg = sum / count;
    
    if (statCount) statCount.textContent = count.toLocaleString('es-MX');
    if (statSum) statSum.textContent = sum.toLocaleString('es-MX');
    if (statAvg) statAvg.textContent = avg.toLocaleString('es-MX', { maximumFractionDigits: 2 });
    if (statsBar) statsBar.style.display = 'block';
  }
  
  // Event listeners para modal ciudadanos
  const btnVerCiudadanos = document.getElementById('btnVerCiudadanos');
  const btnCerrarModal = document.getElementById('btnCerrarModal');
  const modalCiudadanos = document.getElementById('modalCiudadanos');
  
  if (btnVerCiudadanos && !btnVerCiudadanos.hasListener) {
    btnVerCiudadanos.addEventListener('click', () => {
      // Mostrar loading
      showLoading();
      
      // Abrir modal primero
      modalCiudadanos.style.display = 'block';
      
      // Generar solo la tabla activa inicialmente
      setTimeout(() => {
        generarTablaCiudadanos();
        hideLoading();
      }, 50);
    });
    btnVerCiudadanos.hasListener = true;
  }
  
  // Event listeners para cambio de pestañas
  document.querySelectorAll('.tab-btn').forEach(btn => {
    if (!btn.hasListener) {
      btn.addEventListener('click', function() {
        const targetTab = this.getAttribute('data-tab');
        
        // Actualizar botones
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        this.classList.add('active');
        
        // Actualizar contenido
        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
        document.getElementById(targetTab).classList.add('active');
        
        // Limpiar selección al cambiar de pestaña
        if (selectedCells) {
          selectedCells.forEach(c => c.classList.remove('selected'));
          selectedCells.clear();
        }
        const statsBar = document.getElementById('statsBar');
        if (statsBar) statsBar.style.display = 'none';
        
        // Generar tabla de tipos solo cuando se accede a esa pestaña
        if (targetTab === 'tab-tipos') {
          showLoading();
          setTimeout(() => {
            generarTablaTipos();
            hideLoading();
          }, 50);
        }
        
        // Re-habilitar selección en la nueva tabla
        setTimeout(() => habilitarSeleccionCeldas(), 50);
      });
      btn.hasListener = true;
    }
  });
  
  if (btnCerrarModal && !btnCerrarModal.hasListener) {
    btnCerrarModal.addEventListener('click', () => {
      modalCiudadanos.style.display = 'none';
      // Limpiar selección y ocultar barra de estadísticas
      if (selectedCells) {
        selectedCells.forEach(c => c.classList.remove('selected'));
        selectedCells.clear();
      }
      const statsBar = document.getElementById('statsBar');
      if (statsBar) statsBar.style.display = 'none';
      
      // Resetear a primera pestaña
      document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
      document.querySelector('.tab-btn[data-tab="tab-ciudadanos"]').classList.add('active');
      document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
      document.getElementById('tab-ciudadanos').classList.add('active');
    });
    btnCerrarModal.hasListener = true;
  }
  
  // Cerrar modal al hacer clic fuera del contenido
  if (modalCiudadanos && !modalCiudadanos.hasListener) {
    modalCiudadanos.addEventListener('click', (e) => {
      if (e.target === modalCiudadanos) {
        modalCiudadanos.style.display = 'none';
      }
    });
    modalCiudadanos.hasListener = true;
  }

  // Toggle Sidebar
  let sidebarToggleTab = document.getElementById("sidebarToggleTab");
  if (sidebarToggleTab && !sidebarToggleTab.hasListener) {
    let sidebarIsHidden = false; // Estado interno del toggle
    const sidebarWidth = 700; // ancho del sidebar en px (debe coincidir con CSS)
    const tabHeight = 40;
    
    // Función para actualizar el estado visual del sidebar y la pestaña
    function updateSidebarState() {
      const sidebar = document.getElementById('sidebar');
      const tab = document.getElementById('sidebarToggleTab');
      if (!sidebar || !tab) return;
      
      if (sidebarIsHidden) {
        // Ocultar: establecer width a 36px (solo la pestaña visible) y transform
        sidebar.style.width = '36px';
        sidebar.style.padding = '0';
        sidebar.style.overflow = 'visible';
        tab.style.position = 'fixed';
        tab.style.left = '0px';
        tab.style.top = '70px';
        tab.style.width = '36px';
        tab.textContent = '☰';
        console.log('Sidebar ocultado');
      } else {
        // Mostrar: restaurar ancho original
        sidebar.style.width = sidebarWidth + 'px';
        sidebar.style.padding = '10px';
        sidebar.style.overflow = 'auto';
        tab.style.position = 'fixed';
        tab.style.left = (sidebarWidth - 36) + 'px';
        tab.style.top = '70px';
        tab.style.width = '36px';
        tab.textContent = '☰';
        console.log('Sidebar visible');
      }
    }

    // Event listener del toggle
    sidebarToggleTab.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();
      sidebarIsHidden = !sidebarIsHidden;
      console.log('Toggle clicked. Sidebar ahora oculto:', sidebarIsHidden);
      updateSidebarState();
      
      // Actualizar mapa tras transición
      setTimeout(() => {
        if (map && map.invalidateSize) {
          map.invalidateSize();
        }
      }, 350);
    });

    // Reposicionar en resize
    let resizeTimer;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(updateSidebarState, 100);
    });
    
    sidebarToggleTab.hasListener = true;
    // Inicializar al cargar
    setTimeout(updateSidebarState, 100);
  }

  // ========== CONTROLES MAPA: LEYENDA Y TOGGLE PUNTOS ==========
  function createMapControls() {
    // Leyenda
    if (!legendControl) {
      legendControl = L.control({ position: 'topright' });
      legendControl.onAdd = function(map) {
        var div = L.DomUtil.create('div', 'info legend');
        div.id = 'mapLegend';
        div.style.background = 'white';
        div.style.padding = '6px';
        div.style.boxShadow = '0 0 6px rgba(0,0,0,0.3)';
        div.innerHTML = '<b>Solicitudes</b><br>Cargando...';
        L.DomEvent.disableClickPropagation(div);
        return div;
      };
      legendControl.addTo(map);
    }

    // Toggle puntos (icono estilo "ojo")
    if (!puntosToggleControl) {
      puntosToggleControl = L.control({ position: 'topright' });
      puntosToggleControl.onAdd = function(map) {
        var div = L.DomUtil.create('div', 'info toggle');
        div.style.background = 'white';
        div.style.padding = '4px';
        div.style.marginTop = '6px';
        div.style.boxShadow = '0 0 6px rgba(0,0,0,0.15)';
        var btn = document.createElement('button');
        btn.id = 'btnTogglePuntos';
        btn.title = 'Mostrar / Ocultar puntos';
        btn.style.border = 'none';
        btn.style.background = 'transparent';
        btn.style.cursor = 'pointer';
        btn.style.fontSize = '18px';
        btn.style.lineHeight = '1';
        btn.innerHTML = '👁️';
        div.appendChild(btn);
        L.DomEvent.disableClickPropagation(div);

        btn.addEventListener('click', function() {
          showPuntos = !showPuntos;
          if (showPuntos) {
            if (puntosLayer && !map.hasLayer(puntosLayer)) map.addLayer(puntosLayer);
            btn.style.opacity = '1';
          } else {
            if (map.hasLayer(puntosLayer)) map.removeLayer(puntosLayer);
            btn.style.opacity = '0.4';
          }
        });

        return div;
      };
      puntosToggleControl.addTo(map);
    }
  }

  function updateLegend(breaks) {
    var div = document.getElementById('mapLegend');
    if (!div) return;
    if (!breaks || breaks.length === 0) {
      div.innerHTML = '<b>Solicitudes</b><br>No hay datos';
      return;
    }
    var html = '<b>Solicitudes</b><br>';
    for (var i = 0; i < breaks.length; i++) {
      var min = (i === 0) ? 1 : (breaks[i - 1] + 1);
      var max = breaks[i];
      var color = classColor(i);
      html += '<div style="display:flex;align-items:center;margin-bottom:4px"><span style="width:16px;height:12px;background:' + color + ';display:inline-block;margin-right:6px;border:1px solid #555"></span><span>' + min + ' - ' + max + '</span></div>';
    }
    // Agregar vialidades al final
    html += '<div style="margin-top:8px;border-top:1px solid #ddd;padding-top:6px">';
    html += '<div style="display:flex;align-items:center;margin-bottom:4px"><span style="width:16px;height:12px;background:#2563EB;opacity:0.6;border:1px solid #1E40AF;display:inline-block;margin-right:6px;"></span><span>Vialidades Primarias</span></div>';
    html += '</div>';
    div.innerHTML = html;
  }

  // Mostrar aviso de rotación SOLO en dispositivos móviles / pantallas estrechas y en orientación vertical
  function checkOrientation() {
    const rotateDiv = document.getElementById('rotateMessage');
    if (!rotateDiv) return;
    // Mostrar aviso SOLO en pantallas pequeñas (móviles). Evitar mostrar en equipos de escritorio táctiles.
    const isMobileWidth = window.innerWidth <= 768;
    if (isMobileWidth && window.innerHeight > window.innerWidth) {
      rotateDiv.style.display = 'flex';
    } else {
      rotateDiv.style.display = 'none';
    }
    // Reposicionar la pestaña toggle si existe
    try { if (typeof positionToggleTab === 'function') positionToggleTab(); } catch(e){}
    
    // IMPORTANTE: Recalcular isMobile y refrescar mapa al cambiar orientación
    const wasTablet = isMobile;
    isMobile = window.innerWidth <= 768;
    
    if (wasTablet !== isMobile) {
      console.log('📱 Orientación cambiada. isMobile ahora:', isMobile);
      // Refrescar el mapa para que se ajuste correctamente
      if (map && map.invalidateSize) {
        setTimeout(() => {
          map.invalidateSize();
          console.log('✅ Mapa redimensionado');
        }, 100);
      }
      // Redrawing charts con nuevo tamaño
      if (chartTipos) chartTipos.resize();
      if (chartColonias) chartColonias.resize();
      if (chartEstados) chartEstados.resize();
      // Re-inicializar autocompletado si es necesario
      try { if (typeof initializeAutocompleteFallback === 'function') initializeAutocompleteFallback(); } catch(e){}
    }
  }
  
  window.addEventListener('resize', checkOrientation);
  window.addEventListener('orientationchange', checkOrientation);
  window.addEventListener('load', checkOrientation);

  // ========== REGISTRAR SERVICE WORKER PARA PWA ==========
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('./sw.js')
        .then(reg => console.log('✅ Service Worker registrado:', reg.scope))
        .catch(err => console.log('❌ Error registrando Service Worker:', err));
    });
  }

</script>

</body>
</html>
